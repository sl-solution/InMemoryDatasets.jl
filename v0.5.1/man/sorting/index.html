<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sort · InMemoryDatasets</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InMemoryDatasets</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../basics/">First Steps</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../missing/">Missing Values</a></li><li><a class="tocitem" href="../formats/">Formats</a></li><li><a class="tocitem" href="../map/">Call functions on each observation</a></li><li><a class="tocitem" href="../byrow/">Row-wise operations</a></li><li><a class="tocitem" href="../modify/">Transform columns</a></li><li><a class="tocitem" href="../filter/">Filter observations</a></li><li class="is-active"><a class="tocitem" href>Sort</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#sort!/sort"><span><code>sort!/sort</code></span></a></li><li><a class="tocitem" href="#sortperm"><span><code>sortperm</code></span></a></li><li><a class="tocitem" href="#unsort!"><span><code>unsort!</code></span></a></li><li><a class="tocitem" href="#issorted/issorted!"><span><code>issorted</code>/<code>issorted!</code></span></a></li></ul></li><li><a class="tocitem" href="../grouping/">Group observations</a></li><li><a class="tocitem" href="../aggregation/">Aggregation</a></li><li><a class="tocitem" href="../transpose/">Transpose data</a></li><li><a class="tocitem" href="../joins/">Joins</a></li></ul></li><li><a class="tocitem" href="../gallery/">Gallery</a></li><li><a class="tocitem" href="../performance/">Performance tips</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Sort</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sort</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sl-solution/InMemoryDatasets.jl/blob/master/docs/src/man/sorting.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sorting-Datasets"><a class="docs-heading-anchor" href="#Sorting-Datasets">Sorting Datasets</a><a id="Sorting-Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Sorting-Datasets" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Sorting is one of the key tasks for Datasets. Actually, when we group a data set by given set of columns, InMemoryDatasets does sorting behind the scene and groups the observations based on their sorted values. The joining algorithms also uses the sorting functions for finding the matched observations. One may sort a data set based on a set of columns by either their formatted values, or their actual values. In this section we go through the main functions for sorting Datasets.</p><blockquote><p>Note that InMemoryDatasets uses parallel algorithms for sorting observations.</p></blockquote><h2 id="sort!/sort"><a class="docs-heading-anchor" href="#sort!/sort"><code>sort!/sort</code></a><a id="sort!/sort-1"></a><a class="docs-heading-anchor-permalink" href="#sort!/sort" title="Permalink"></a></h2><p>The <code>sort!</code> function accepts a Dataset and a set of columns and sorts the given Dataset based on provided columns. By default the <code>sort!</code> function does the sorting based on the formatted values, however, using <code>mapformats = false</code> forces the sorting be done based on the actual values. <code>sort!</code> doesn&#39;t create a new dataset, it only replaces the original one with the sorted one. If the original data set needed to be untouched the <code>sort</code> function must be used. By default, both <code>sort!</code> and <code>sort</code> functions do a stable sort using a hybrid <code>Heap</code> sort algorithm. If the stability of the sort is not needed, using the keyword option <code>stable = false</code> can improve the performance. User can also change the default sorting algorithm to hybrid <code>QuickSort</code> by using the <code>alg = QuickSort</code> option. By default the ascending sorting is used for the sorting task, and using <code>rev = true</code> changes it to descending ordering, and for multiple columns a vector of  <code>true</code>, <code>false</code> can be supplied for this option, i.e. each column can be sorted in ascending or descending order independently. Note that:</p><ul><li><p>Datasets uses <code>isless</code> for checking the order of values.</p></li><li><p>Datasets prints extra information when it shows a sorted data set.</p></li><li><p>Like Julia Base, the missing values are treated larger than any other values.</p></li><li><p><code>sort</code> creates a copy of data and permutes each column of it and attaches some attributes to the new data set. To sort a data set without creating a new data set or modifying the original data set, someone may use the <code>groupby</code> function. The <code>groupby</code> function sorts and then creates a meta information about the sorted data set. The <code>groupby</code> function will be discussed in another section in detail.</p></li></ul><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(x = [5,4,3,2,1], y = [42,52,4,1,55])
5×2 Dataset
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        5        42
   2 │        4        52
   3 │        3         4
   4 │        2         1
   5 │        1        55

julia&gt; sort!(ds, :x);
julia&gt; ds
5×2 Sorted Dataset
 Sorted by: x
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        1        55
   2 │        2         1
   3 │        3         4
   4 │        4        52
   5 │        5        42

julia&gt; sort(ds, :y, rev = true)
5×2 Sorted Dataset
 Sorted by: y
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        1        55
   2 │        4        52
   3 │        5        42
   4 │        3         4
   5 │        2         1

julia&gt; ds = Dataset(x = [5, 4, missing, 4],
                    y = [3, missing, missing , 1])
4×2 Dataset
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        5         3
   2 │        4   missing
   3 │  missing   missing
   4 │        4         1

julia&gt; sort(ds, 1:2)
4×2 Sorted Dataset
 Sorted by: x, y
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        4         1
   2 │        4   missing
   3 │        5         3
   4 │  missing   missing

julia&gt; sort(ds, 1:2, rev = [false, true])
4×2 Sorted Dataset
 Sorted by: x, y
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        4   missing
   2 │        4         1
   3 │        5         3
   4 │  missing   missing</code></pre><p>The following examples show how the sorting functions work with formats.</p><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(state = [&quot;CA&quot;, &quot;TX&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;CA&quot;, &quot;TX&quot;, &quot;TX&quot;],
                    date = [Date(&quot;2020-01-01&quot;), Date(&quot;2020-03-01&quot;), Date(&quot;2020-01-01&quot;),
                            Date(&quot;2020-03-01&quot;), Date(&quot;2020-02-01&quot;), Date(&quot;2021-03-01&quot;),
                            Date(&quot;2021-02-01&quot;), Date(&quot;2020-02-01&quot;)],
                      qt = [123, 143, 144, 199, 153, 144, 134, 188])
8×3 Dataset
 Row │ state     date        qt       
     │ identity  identity    identity
     │ String?   Date?       Int64?   
─────┼────────────────────────────────
   1 │ CA        2020-01-01       123
   2 │ TX        2020-03-01       143
   3 │ IL        2020-01-01       144
   4 │ IL        2020-03-01       199
   5 │ IL        2020-02-01       153
   6 │ CA        2021-03-01       144
   7 │ TX        2021-02-01       134
   8 │ TX        2020-02-01       188

julia&gt; setformat!(ds, :date=&gt;month)
8×3 Dataset
 Row │ state     date   qt       
     │ identity  month  identity
     │ String?   Date?  Int64?   
─────┼───────────────────────────
   1 │ CA        1           123
   2 │ TX        3           143
   3 │ IL        1           144
   4 │ IL        3           199
   5 │ IL        2           153
   6 │ CA        3           144
   7 │ TX        2           134
   8 │ TX        2           188

julia&gt; sort(ds, [2,1])
8×3 Sorted Dataset
 Sorted by: date, state
 Row │ state     date   qt       
     │ identity  month  identity
     │ String?   Date?  Int64?   
─────┼───────────────────────────
   1 │ CA        1           123
   2 │ IL        1           144
   3 │ IL        2           153
   4 │ TX        2           134
   5 │ TX        2           188
   6 │ CA        3           144
   7 │ IL        3           199
   8 │ TX        3           143

julia&gt; sort(ds, [2,1], mapformats = false)
8×3 Sorted Dataset
 Sorted by: date, state
 Row │ state     date   qt       
     │ identity  month  identity
     │ String?   Date?  Int64?   
─────┼───────────────────────────
   1 │ CA        1           123
   2 │ IL        1           144
   3 │ IL        2           153
   4 │ TX        2           188
   5 │ IL        3           199
   6 │ TX        3           143
   7 │ TX        2           134
   8 │ CA        3           144

julia&gt; sort(ds, [1,2], mapformats = false)
8×3 Sorted Dataset
 Sorted by: state, date
 Row │ state     date   qt       
     │ identity  month  identity
     │ String?   Date?  Int64?   
─────┼───────────────────────────
   1 │ CA        1           123
   2 │ CA        3           144
   3 │ IL        1           144
   4 │ IL        2           153
   5 │ IL        3           199
   6 │ TX        2           188
   7 │ TX        3           143
   8 │ TX        2           134</code></pre><p>In some scenarios the performance of sort can be improved by using formats. For example, when we know for a specific column there is only a few numbers after the decimal point, using a format can improve the performance of the sort. In the following example we are using the <code>@btime</code> macro from the <code>BenchmarkTools</code> package to demonstrate this;</p><pre><code class="language-julia-repl hljs"># column :x1 has at most 2 digits after the decimal point
julia&gt; ds = Dataset(x1 = round.(rand(10^6),digits = 2),
               x2 = repeat(1:100, 10^4));
julia&gt; @btime sort(ds, 1);
  56.278 ms (1661 allocations: 67.65 MiB)

julia&gt; custom_fmt(x) = round(x * 100);
julia&gt; setformat!(ds, 1=&gt;custom_fmt);
julia&gt; @btime sort(ds, 1);
  13.718 ms (446 allocations: 53.44 MiB)</code></pre><p>The 4 times improvement in the performance is due to the fact that the formatted values in the data set are basically integer rather than float (the actual values) and the algorithms for sorting integers are usually faster than those for sorting double precision numbers.</p><p>Another trick can be used for situations when a data set contains a column of string values where the values can be treated as numbers, e.g. in the following code <code>:x1</code> is basically integer values with <code>&quot;id&quot;</code> been attached to each value, here we use a customised format that extracts the numeric values from <code>:x1</code>;</p><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(x1 = &quot;id&quot; .* string.(rand(1:100000, 10^6)));
julia&gt; @btime sort(ds, 1);
  296.101 ms (612 allocations: 54.40 MiB)
julia&gt; custom_fmt(x) = parse(Int, @views x[3:end])
   custom_fmt (generic function with 1 method)
julia&gt; setformat!(ds, 1=&gt;custom_fmt);
julia&gt; @btime sort(ds, 1)
  38.057 ms (323 allocations: 44.27 MiB)</code></pre><h2 id="sortperm"><a class="docs-heading-anchor" href="#sortperm"><code>sortperm</code></a><a id="sortperm-1"></a><a class="docs-heading-anchor-permalink" href="#sortperm" title="Permalink"></a></h2><p>The <code>sortperm(ds, cols)</code> function returns a permutation vector <code>perm</code> that puts <code>ds[perm, :]</code> in sorted order based on <code>cols</code>. Similar to <code>sort!</code>/<code>sort</code>, this function accepts <code>rev</code>, <code>alg</code>, <code>mapformats</code> and <code>stable</code> options.</p><h3 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(x = [1,4,3,2,1], y = [420,52,4,1,55])
5×2 Dataset
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        1       420
   2 │        4        52
   3 │        3         4
   4 │        2         1
   5 │        1        55

julia&gt; p = sortperm(ds, [1,2])
5-element Vector{Int32}:
5
1
4
3
2

julia&gt; ds[p, :]
5×2 Dataset
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        1        55
   2 │        1       420
   3 │        2         1
   4 │        3         4
   5 │        4        52</code></pre><h2 id="unsort!"><a class="docs-heading-anchor" href="#unsort!"><code>unsort!</code></a><a id="unsort!-1"></a><a class="docs-heading-anchor-permalink" href="#unsort!" title="Permalink"></a></h2><p>The <code>unsort!</code> function undo the last sort operation that has been done on a data set, i.e. when a <code>sort!</code> function has been applied to a data set, directly or indirectly (e.g. the <code>groupby!</code> function is one of the functions which uses <code>sort!</code> behind the scene), the <code>unsort!</code> function can undo it.</p><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(x = [1,3,1,2,6,1,4,4],
                    y = [100,150,90,110,100,80,50,30])
8×2 Dataset
Row │ x         y        
    │ identity  identity
    │ Int64?    Int64?   
────┼────────────────────
  1 │        1       100
  2 │        3       150
  3 │        1        90
  4 │        2       110
  5 │        6       100
  6 │        1        80
  7 │        4        50
  8 │        4        30

julia&gt; sort!(ds, 1:2);
julia&gt; ds
8×2 Sorted Dataset
 Sorted by: x, y
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        1        80
   2 │        1        90
   3 │        1       100
   4 │        2       110
   5 │        3       150
   6 │        4        30
   7 │        4        50
   8 │        6       100

julia&gt; unsort!(ds)
8×2 Dataset
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        1       100
   2 │        3       150
   3 │        1        90
   4 │        2       110
   5 │        6       100
   6 │        1        80
   7 │        4        50
   8 │        4        30</code></pre><h2 id="issorted/issorted!"><a class="docs-heading-anchor" href="#issorted/issorted!"><code>issorted</code>/<code>issorted!</code></a><a id="issorted/issorted!-1"></a><a class="docs-heading-anchor-permalink" href="#issorted/issorted!" title="Permalink"></a></h2><p>The <code>issorted</code> function checks if a data set is sorted by given column(s). The syntax for the function is <code>issorted(ds, cols)</code>, and by default the <code>mapformats</code> keyword argument is set to <code>true</code> and the <code>rev</code> keyword argument is set to <code>false</code>. The <code>issorted!</code> function does the same job, however, if it returns <code>true</code> it marks the input data set as a sorted data set, i.e. it attaches some meta information to the data set.</p><h3 id="Examples-3"><a class="docs-heading-anchor" href="#Examples-3">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-3" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(x1 = [1, 4, 7], x2 = [3.0, 1.1, -10.0], x3 = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])
3×3 Dataset
 Row │ x1        x2        x3       
     │ identity  identity  identity
     │ Int64?    Float64?  String?  
─────┼──────────────────────────────
   1 │        1       3.0  one
   2 │        4       1.1  two
   3 │        7     -10.0  three

julia&gt; issorted(ds, 1)
true

julia&gt; issorted(ds, 2)
false

julia&gt; issorted(ds, 2, rev = true)
true

julia&gt; julia&gt; fmt(x) = x == &quot;one&quot; ? 1 : x==&quot;two&quot; ? 2 : 3
fmt (generic function with 1 method)

julia&gt; setformat!(ds, :x3=&gt;fmt)
3×3 Dataset
 Row │ x1        x2        x3      
     │ identity  identity  fmt     
     │ Int64?    Float64?  String?
─────┼─────────────────────────────
   1 │        1       3.0  1
   2 │        4       1.1  2
   3 │        7     -10.0  3

julia&gt; issorted(ds, 3)
true

julia&gt; issorted!(ds, 1:3, rev = [false, true, false])
true

julia&gt; ds
3×3 Sorted Dataset
 Sorted by: x1, x2, x3
 Row │ x1        x2        x3      
     │ identity  identity  fmt     
     │ Int64?    Float64?  String?
─────┼─────────────────────────────
   1 │        1       3.0  1
   2 │        4       1.1  2
   3 │        7     -10.0  3</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../filter/">« Filter observations</a><a class="docs-footer-nextpage" href="../grouping/">Group observations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 20 December 2021 10:55">Monday 20 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
