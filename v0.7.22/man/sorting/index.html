<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sort · InMemoryDatasets</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">InMemoryDatasets</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../basics/">First Steps</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../missing/">Missing Values</a></li><li><a class="tocitem" href="../formats/">Formats</a></li><li><a class="tocitem" href="../map/">Call functions on each observation</a></li><li><a class="tocitem" href="../byrow/">Row-wise operations</a></li><li><a class="tocitem" href="../modify/">Transform columns</a></li><li><a class="tocitem" href="../filter/">Filter observations</a></li><li class="is-active"><a class="tocitem" href>Sort</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#sort!/sort"><span><code>sort!/sort</code></span></a></li><li><a class="tocitem" href="#sortperm"><span><code>sortperm</code></span></a></li><li><a class="tocitem" href="#unsort!"><span><code>unsort!</code></span></a></li><li><a class="tocitem" href="#issorted/issorted!"><span><code>issorted</code>/<code>issorted!</code></span></a></li><li><a class="tocitem" href="#Performance-improvement-using-formats"><span>Performance improvement using <code>formats</code></span></a></li></ul></li><li><a class="tocitem" href="../grouping/">Group observations</a></li><li><a class="tocitem" href="../aggregation/">Aggregation</a></li><li><a class="tocitem" href="../transpose/">Transpose data</a></li><li><a class="tocitem" href="../joins/">Joins</a></li></ul></li><li><a class="tocitem" href="../gallery/">Gallery</a></li><li><a class="tocitem" href="../performance/">Performance tips</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">User Guide</a></li><li class="is-active"><a href>Sort</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sort</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sl-solution/InMemoryDatasets.jl/blob/master/docs/src/man/sorting.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Sorting-Datasets"><a class="docs-heading-anchor" href="#Sorting-Datasets">Sorting Datasets</a><a id="Sorting-Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Sorting-Datasets" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Sorting is one of the key tasks for Datasets. Actually, when we group a data set by given set of columns, InMemoryDatasets does sorting behind the scene and groups the observations based on their sorted values. The joining algorithms also uses the sorting functions for finding the matched observations. One may sort a data set based on a set of columns by either their formatted values, or their actual values. In this section we go through the main functions for sorting Datasets.</p><blockquote><p>Note that, by default, InMemoryDatasets uses parallel algorithms for sorting observations. User may stop parallel sorting by passing <code>threads = false</code>.</p></blockquote><h2 id="sort!/sort"><a class="docs-heading-anchor" href="#sort!/sort"><code>sort!/sort</code></a><a id="sort!/sort-1"></a><a class="docs-heading-anchor-permalink" href="#sort!/sort" title="Permalink"></a></h2><p>The <code>sort!</code> function accepts a Dataset and a set of columns and sorts the given Dataset based on provided columns. By default the <code>sort!</code> function does the sorting based on the formatted values, however, using <code>mapformats = false</code> forces the sorting be done based on the actual values. <code>sort!</code> doesn&#39;t create a new dataset, it only replaces the original one with the sorted one. If the original data set needed to be untouched the <code>sort</code> function must be used. By default, both <code>sort!</code> and <code>sort</code> functions do a stable sort using a hybrid <code>Heap</code> sort algorithm. If the stability of the sort is not needed, using the keyword option <code>stable = false</code> can improve the performance. User can also change the default sorting algorithm to hybrid <code>QuickSort</code> by using the <code>alg = QuickSort</code> option. For most problems <code>QuickSort</code> algorithm is faster than the default algorithm, however, its worst case scenario is slower than the default algorithm.</p><p>By default the ascending sorting is used for the sorting task, and using <code>rev = true</code> changes it to descending ordering, and for multiple columns a vector of  <code>true</code>, <code>false</code> can be supplied for this option, i.e. each column can be sorted in ascending or descending order independently. Note that:</p><ul><li><p>Datasets uses <code>isless</code> for checking the order of values.</p></li><li><p>Datasets prints extra information when it shows a sorted data set.</p></li><li><p>Like Julia Base, the missing values are treated larger than any other values.</p></li><li><p><code>sort</code> creates a copy of data and permutes each column of it and attaches some attributes to the new data set. To sort a data set without creating a new data set or modifying the original data set, someone may use the <code>groupby</code> function. The <code>groupby</code> function sorts and then creates a meta information about the sorted data set. The <code>groupby</code> function will be discussed in another section in detail.</p></li></ul><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(x = [5,4,3,2,1], y = [42,52,4,1,55])
5×2 Dataset
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        5        42
   2 │        4        52
   3 │        3         4
   4 │        2         1
   5 │        1        55

julia&gt; sort!(ds, :x);
julia&gt; ds
5×2 Sorted Dataset
 Sorted by: x
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        1        55
   2 │        2         1
   3 │        3         4
   4 │        4        52
   5 │        5        42

julia&gt; sort(ds, :y, rev = true)
5×2 Sorted Dataset
 Sorted by: y
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        1        55
   2 │        4        52
   3 │        5        42
   4 │        3         4
   5 │        2         1

julia&gt; ds = Dataset(x = [5, 4, missing, 4],
                    y = [3, missing, missing , 1])
4×2 Dataset
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        5         3
   2 │        4   missing
   3 │  missing   missing
   4 │        4         1

julia&gt; sort(ds, 1:2)
4×2 Sorted Dataset
 Sorted by: x, y
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        4         1
   2 │        4   missing
   3 │        5         3
   4 │  missing   missing

julia&gt; sort(ds, 1:2, rev = [false, true])
4×2 Sorted Dataset
 Sorted by: x, y
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        4   missing
   2 │        4         1
   3 │        5         3
   4 │  missing   missing</code></pre><p>The following examples show how the sorting functions work with formats.</p><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(state = [&quot;CA&quot;, &quot;TX&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;IL&quot;, &quot;CA&quot;, &quot;TX&quot;, &quot;TX&quot;],
                    date = [Date(&quot;2020-01-01&quot;), Date(&quot;2020-03-01&quot;), Date(&quot;2020-01-01&quot;),
                            Date(&quot;2020-03-01&quot;), Date(&quot;2020-02-01&quot;), Date(&quot;2021-03-01&quot;),
                            Date(&quot;2021-02-01&quot;), Date(&quot;2020-02-01&quot;)],
                      qt = [123, 143, 144, 199, 153, 144, 134, 188])
8×3 Dataset
 Row │ state     date        qt       
     │ identity  identity    identity
     │ String?   Date?       Int64?   
─────┼────────────────────────────────
   1 │ CA        2020-01-01       123
   2 │ TX        2020-03-01       143
   3 │ IL        2020-01-01       144
   4 │ IL        2020-03-01       199
   5 │ IL        2020-02-01       153
   6 │ CA        2021-03-01       144
   7 │ TX        2021-02-01       134
   8 │ TX        2020-02-01       188

julia&gt; setformat!(ds, :date=&gt;month)
8×3 Dataset
 Row │ state     date   qt       
     │ identity  month  identity
     │ String?   Date?  Int64?   
─────┼───────────────────────────
   1 │ CA        1           123
   2 │ TX        3           143
   3 │ IL        1           144
   4 │ IL        3           199
   5 │ IL        2           153
   6 │ CA        3           144
   7 │ TX        2           134
   8 │ TX        2           188

julia&gt; sort(ds, [2,1])
8×3 Sorted Dataset
 Sorted by: date, state
 Row │ state     date   qt       
     │ identity  month  identity
     │ String?   Date?  Int64?   
─────┼───────────────────────────
   1 │ CA        1           123
   2 │ IL        1           144
   3 │ IL        2           153
   4 │ TX        2           134
   5 │ TX        2           188
   6 │ CA        3           144
   7 │ IL        3           199
   8 │ TX        3           143

julia&gt; sort(ds, [2,1], mapformats = false)
8×3 Sorted Dataset
 Sorted by: date, state
 Row │ state     date   qt       
     │ identity  month  identity
     │ String?   Date?  Int64?   
─────┼───────────────────────────
   1 │ CA        1           123
   2 │ IL        1           144
   3 │ IL        2           153
   4 │ TX        2           188
   5 │ IL        3           199
   6 │ TX        3           143
   7 │ TX        2           134
   8 │ CA        3           144

julia&gt; sort(ds, [1,2], mapformats = false)
8×3 Sorted Dataset
 Sorted by: state, date
 Row │ state     date   qt       
     │ identity  month  identity
     │ String?   Date?  Int64?   
─────┼───────────────────────────
   1 │ CA        1           123
   2 │ CA        3           144
   3 │ IL        1           144
   4 │ IL        2           153
   5 │ IL        3           199
   6 │ TX        2           188
   7 │ TX        3           143
   8 │ TX        2           134</code></pre><h2 id="sortperm"><a class="docs-heading-anchor" href="#sortperm"><code>sortperm</code></a><a id="sortperm-1"></a><a class="docs-heading-anchor-permalink" href="#sortperm" title="Permalink"></a></h2><p>The <code>sortperm(ds, cols)</code> function returns a permutation vector <code>perm</code> that puts <code>ds[perm, :]</code> in sorted order based on <code>cols</code>. Similar to <code>sort!</code>/<code>sort</code>, this function accepts <code>rev</code>, <code>alg</code>, <code>mapformats</code> and <code>stable</code> options.</p><h3 id="Examples-2"><a class="docs-heading-anchor" href="#Examples-2">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-2" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(x = [1,4,3,2,1], y = [420,52,4,1,55])
5×2 Dataset
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        1       420
   2 │        4        52
   3 │        3         4
   4 │        2         1
   5 │        1        55

julia&gt; p = sortperm(ds, [1,2])
5-element Vector{Int32}:
5
1
4
3
2

julia&gt; ds[p, :]
5×2 Dataset
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        1        55
   2 │        1       420
   3 │        2         1
   4 │        3         4
   5 │        4        52</code></pre><p>In the following example we show the performance difference between the default algorithm and <code>QuickSort</code> algorithm for sorting Integers.</p><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(x = rand(Int, 10^8));
julia&gt; @time sortperm(ds,1, stable = false);
 21.663503 seconds (604 allocations: 2.887 GiB, 0.11% gc time)
julia&gt; @time sortperm(ds,1, stable = false, alg = QuickSort);
 4.818334 seconds (591 allocations: 2.887 GiB, 7.05% gc time)</code></pre><h2 id="unsort!"><a class="docs-heading-anchor" href="#unsort!"><code>unsort!</code></a><a id="unsort!-1"></a><a class="docs-heading-anchor-permalink" href="#unsort!" title="Permalink"></a></h2><p>The <code>unsort!</code> function undo the last sort operation that has been done on a data set, i.e. when a <code>sort!</code> function has been applied to a data set, directly or indirectly (e.g. the <code>groupby!</code> function is one of the functions which uses <code>sort!</code> behind the scene), the <code>unsort!</code> function can undo it.</p><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(x = [1,3,1,2,6,1,4,4],
                    y = [100,150,90,110,100,80,50,30])
8×2 Dataset
Row │ x         y        
    │ identity  identity
    │ Int64?    Int64?   
────┼────────────────────
  1 │        1       100
  2 │        3       150
  3 │        1        90
  4 │        2       110
  5 │        6       100
  6 │        1        80
  7 │        4        50
  8 │        4        30

julia&gt; sort!(ds, 1:2);
julia&gt; ds
8×2 Sorted Dataset
 Sorted by: x, y
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        1        80
   2 │        1        90
   3 │        1       100
   4 │        2       110
   5 │        3       150
   6 │        4        30
   7 │        4        50
   8 │        6       100

julia&gt; unsort!(ds)
8×2 Dataset
 Row │ x         y        
     │ identity  identity
     │ Int64?    Int64?   
─────┼────────────────────
   1 │        1       100
   2 │        3       150
   3 │        1        90
   4 │        2       110
   5 │        6       100
   6 │        1        80
   7 │        4        50
   8 │        4        30</code></pre><h2 id="issorted/issorted!"><a class="docs-heading-anchor" href="#issorted/issorted!"><code>issorted</code>/<code>issorted!</code></a><a id="issorted/issorted!-1"></a><a class="docs-heading-anchor-permalink" href="#issorted/issorted!" title="Permalink"></a></h2><p>The <code>issorted</code> function checks if a data set is sorted by given column(s). The syntax for the function is <code>issorted(ds, cols)</code>, and by default the <code>mapformats</code> keyword argument is set to <code>true</code> and the <code>rev</code> keyword argument is set to <code>false</code>. The <code>issorted!</code> function does the same job, however, if it returns <code>true</code> it marks the input data set as a sorted data set, i.e. it attaches some meta information to the data set.</p><h3 id="Examples-3"><a class="docs-heading-anchor" href="#Examples-3">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-3" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(x1 = [1, 4, 7], x2 = [3.0, 1.1, -10.0], x3 = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])
3×3 Dataset
 Row │ x1        x2        x3       
     │ identity  identity  identity
     │ Int64?    Float64?  String?  
─────┼──────────────────────────────
   1 │        1       3.0  one
   2 │        4       1.1  two
   3 │        7     -10.0  three

julia&gt; issorted(ds, 1)
true

julia&gt; issorted(ds, 2)
false

julia&gt; issorted(ds, 2, rev = true)
true

julia&gt; fmt(x) = x == &quot;one&quot; ? 1 : x==&quot;two&quot; ? 2 : 3
fmt (generic function with 1 method)

julia&gt; setformat!(ds, :x3=&gt;fmt)
3×3 Dataset
 Row │ x1        x2        x3      
     │ identity  identity  fmt     
     │ Int64?    Float64?  String?
─────┼─────────────────────────────
   1 │        1       3.0  1
   2 │        4       1.1  2
   3 │        7     -10.0  3

julia&gt; issorted(ds, 3)
true

julia&gt; issorted!(ds, 1:3, rev = [false, true, false])
true

julia&gt; ds
3×3 Sorted Dataset
 Sorted by: x1, x2, x3
 Row │ x1        x2        x3      
     │ identity  identity  fmt     
     │ Int64?    Float64?  String?
─────┼─────────────────────────────
   1 │        1       3.0  1
   2 │        4       1.1  2
   3 │        7     -10.0  3</code></pre><h2 id="Performance-improvement-using-formats"><a class="docs-heading-anchor" href="#Performance-improvement-using-formats">Performance improvement using <code>formats</code></a><a id="Performance-improvement-using-formats-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-improvement-using-formats" title="Permalink"></a></h2><p>In some scenarios the performance of sort can be improved by using formats. For example, when we know for a specific column there is only a few numbers after the decimal point, using a format can improve the performance of the sort. In the following example we are using the <code>@btime</code> macro from the <code>BenchmarkTools</code> package to demonstrate this;</p><pre><code class="language-julia-repl hljs">julia&gt; ;# column :x1 has at most 2 digits after the decimal point
julia&gt; ds = Dataset(x1 = round.(rand(10^6),digits = 2),
               x2 = repeat(1:100, 10^4));
julia&gt; @btime sortperm(ds, 1);
  37.169 ms (751 allocations: 31.53 MiB)

julia&gt; custom_fmt(x) = round(x * 100);

julia&gt; setformat!(ds, 1=&gt;custom_fmt);

julia&gt; @btime sortperm(ds, 1);
  5.678 ms (317 allocations: 17.19 MiB)</code></pre><p>The 6 times improvement in the performance is due to the fact that the formatted values in the data set are basically integer rather than float (the actual values) and the algorithms for sorting integers are usually faster than those for sorting double precision numbers.</p><p>This can be generalised to situations where the numbers after the decimal point is not known, e.g. suppose we have the following data set</p><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(x = rand(10^6))</code></pre><p>in this case we cannot use the round trick directly, however, we can create an alias of <code>:x</code> and partially apply <code>round</code> trick on alias column and sort the data set based on both columns,</p><pre><code class="language-julia-repl hljs">julia&gt; fmt(x) = round(Int, x*100) # split data up to 100 parts
julia&gt; modify!(ds, :x =&gt; identity =&gt; :_tmp) # alias of :x - This is an instance operation
julia&gt; setformat!(ds, :_tmp=&gt;fmt)
julia&gt; @btime sortperm(ds, [:x], alg = QuickSort); # without using formats
  36.460 ms (508 allocations: 29.60 MiB)

julia&gt; @btime sortperm(ds, [:_tmp, :x], alg = QuickSort);
  17.550 ms (505 allocations: 25.79 MiB)</code></pre><p>This works because the second method exploits integer and float sorting algorithms and also utilises multiple cpus more efficiently.</p><p>Another trick can be used for situations when a data set contains a column of string values where the values can be treated as numbers, e.g. in the following code <code>:x1</code> is basically integer values with <code>&quot;id&quot;</code> been attached to each value, here we use a customised format that extracts the numeric values from <code>:x1</code>;</p><pre><code class="language-julia-repl hljs">julia&gt; ds = Dataset(x1 = &quot;id&quot; .* string.(rand(1:100000, 10^6)));
julia&gt; @btime sortperm(ds, 1);
  257.070 ms (580 allocations: 27.70 MiB)

julia&gt; custom_fmt(x) = parse(Int, @views x[3:end])
custom_fmt (generic function with 1 method)

julia&gt; setformat!(ds, 1=&gt;custom_fmt);

julia&gt; @btime sortperm(ds, 1);
  15.456 ms (278 allocations: 17.57 MiB)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../filter/">« Filter observations</a><a class="docs-footer-nextpage" href="../grouping/">Group observations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 15 October 2025 04:07">Wednesday 15 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
