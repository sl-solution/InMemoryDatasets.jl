var documenterSearchIndex = {"docs":
[{"location":"man/aggregation/#Aggregation","page":"Aggregation","title":"Aggregation","text":"","category":"section"},{"location":"man/aggregation/#Introduction","page":"Aggregation","title":"Introduction","text":"","category":"section"},{"location":"man/aggregation/","page":"Aggregation","title":"Aggregation","text":"In previous sections we discuss the main functions (groupby!, groupby, and gatherby) to group observations in a data set. In this section we introduce a function which can be used to apply a function on each group of observations.","category":"page"},{"location":"man/aggregation/#combine","page":"Aggregation","title":"combine","text":"","category":"section"},{"location":"man/aggregation/","page":"Aggregation","title":"Aggregation","text":"combine is a function which accepts a grouped data set - created by groupby!, groupby, or gatherby - and a set of operations in the form of cols => fun, where cols is a column selector, and applies fun on each columns in cols. The operations can be passed as col => fun => :newname if user likes to have a specific column name for the output column. All columns selected by cols are assumed to be referring to the same columns in the input data set. However, when the passed fun is a byrow function then combine assumes every column in cols are referring to the existing columns in the output data set. Thus, unlike modify!/modify, combine only can access to the existing columns in the output data set when the fun is a byrow function.","category":"page"},{"location":"man/aggregation/","page":"Aggregation","title":"Aggregation","text":"The order of the output data set depends on the passed data set, i.e. for groupby the order of the output is sorted order of the grouping columns, and for gatherby data set the order of the output is based on the appearance of observations in the original data set. Since for most situations, the stability of grouping is not needed, passing stable = false in groupby/gatherby can improve the performance, but when stable = false for gatherby, the order of the output is undefined.","category":"page"},{"location":"man/aggregation/","page":"Aggregation","title":"Aggregation","text":"By default, combine outputs the grouping columns in the final result, however, passing dropgroupcols = true removes them from the final output.","category":"page"},{"location":"man/aggregation/","page":"Aggregation","title":"Aggregation","text":"By default combine send each group of data to different threads for processing (multithreaded processing), however, passing threads = false changes this.","category":"page"},{"location":"man/aggregation/#Examples","page":"Aggregation","title":"Examples","text":"","category":"section"},{"location":"man/aggregation/","page":"Aggregation","title":"Aggregation","text":"julia> ds = Dataset(g = [1,2,1,2,1,2], x = 1:6)\n6×2 Dataset\n Row │ g         x        \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1         1\n   2 │        2         2\n   3 │        1         3\n   4 │        2         4\n   5 │        1         5\n   6 │        2         6\n\njulia> combine(groupby(ds, :g), :x=>[IMD.sum, mean])\n2×3 Dataset\n Row │ g         sum_x     mean_x   \n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1         9       3.0\n   2 │        2        12       4.0\n\njulia> combine(gatherby(ds, :g), :x => [IMD.maximum, IMD.minimum], 2:3 => byrow(-) => :range)\n2×4 Dataset\n Row │ g         maximum_x  minimum_x  range    \n     │ identity  identity   identity   identity\n     │ Int64?    Int64?     Int64?     Int64?   \n─────┼──────────────────────────────────────────\n   1 │        1          5          1         4\n   2 │        2          6          2         4\n\njulia> ds = Dataset(rand(1:10, 10, 4), :auto)\n10×4 Dataset\n Row │ x1        x2        x3        x4       \n     │ identity  identity  identity  identity\n     │ Int64?    Int64?    Int64?    Int64?   \n─────┼────────────────────────────────────────\n   1 │        9         1         6         3\n   2 │       10         7        10         6\n   3 │        7         7         3         9\n   4 │        9         4        10         8\n   5 │        7         3         4         5\n   6 │        2         6         5         6\n   7 │        1         6         6         1\n   8 │       10         2         7         6\n   9 │        5        10         9         6\n  10 │        1         1         3         4\n\njulia> combine(gatherby(ds, 1), r\"x\" => IMD.sum)\n6×5 Dataset\n Row │ x1        sum_x1    sum_x2    sum_x3    sum_x4   \n     │ identity  identity  identity  identity  identity\n     │ Int64?    Int64?    Int64?    Int64?    Int64?   \n─────┼──────────────────────────────────────────────────\n   1 │        9        18         5        16        11\n   2 │       10        20         9        17        12\n   3 │        7        14        10         7        14\n   4 │        2         2         6         5         6\n   5 │        1         2         7         9         5\n   6 │        5         5        10         9         6\n\njulia> ds = Dataset(g = [1,2,1,2,1,2], x = 1:6)\n6×2 Dataset\n Row │ g         x        \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1         1\n   2 │        2         2\n   3 │        1         3\n   4 │        2         4\n   5 │        1         5\n   6 │        2         6\n\njulia> combine(gatherby(ds, :g), :x=>[IMD.maximum, IMD.minimum], 2:3=>byrow(-)=>:range, dropgroupcols = true)\n2×3 Dataset\n Row │ maximum_x  minimum_x  range    \n     │ identity   identity   identity\n     │ Int64?     Int64?     Int64?   \n─────┼────────────────────────────────\n   1 │         5          1         4\n   2 │         6          2         4","category":"page"},{"location":"man/aggregation/","page":"Aggregation","title":"Aggregation","text":"combine treats each columns in cols individually, thus, a function can be applied to each column by cols => fun form. combine normalises cols => funs to col1 => funs, col2 => funs, ..., where col1 refers to the first column in the column selector cols, col2 refers to the second one, .... When col => funs is passed to the function where col refers to a single column, combine normalises it as col => fun1, col => fun2, ..., where fun1, fun2,... are the first, second, ... functions in passed funs.","category":"page"},{"location":"man/aggregation/","page":"Aggregation","title":"Aggregation","text":"Any reduction on multiple columns should be go through a byrow approach.","category":"page"},{"location":"man/aggregation/","page":"Aggregation","title":"Aggregation","text":"In special cases, where users like to apply a multivariate function on a set of columns, the columns which are going to be the argument of the multivariate function must be passed as a Tuple of column names or column indices.","category":"page"},{"location":"man/aggregation/","page":"Aggregation","title":"Aggregation","text":"julia> ds = Dataset(g = [1,1,1,2,2,2],\n            x1 = [1.2, 2.3, 1.3, 2.4, 4.5, 5.1],\n            x2 = [11, 12.0, 11.0, 12.3, 14.5, 16.9])\n6×3 Dataset\nRow │ g         x1        x2       \n    │ identity  identity  identity\n    │ Int64?    Float64?  Float64?\n────┼──────────────────────────────\n  1 │        1       1.2      11.0\n  2 │        1       2.3      12.0\n  3 │        1       1.3      11.0\n  4 │        2       2.4      12.3\n  5 │        2       4.5      14.5\n  6 │        2       5.1      16.9\n\njulia> combine(gatherby(ds, 1, isgathered=true), (2,3)=>cor)\n2×2 Dataset\nRow │ g         cor_x1_x2\n    │ identity  identity  \n    │ Int64?    Float64?  \n────┼─────────────────────\n  1 │        1   0.996616\n  2 │        2   0.944252\n","category":"page"},{"location":"man/basics/#First-steps-with-Datasets","page":"First Steps","title":"First steps with Datasets","text":"","category":"section"},{"location":"man/basics/#Setting-up-the-environment","page":"First Steps","title":"Setting up the environment","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"To install in memory Datasets package , simply, use the following commands inside a Julia session:","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> using Pkg\njulia> Pkg.add(\"InMemoryDatasets\")","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Throughout the rest of the tutorial we will assume that you have installed the \"In-Memory Datasets\" package and have already typed using InMemoryDatasets which loads the package:","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> using InMemoryDatasets","category":"page"},{"location":"man/basics/#Creating-a-data-set","page":"First Steps","title":"Creating a data set","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"To create a data set, use Dataset(). For example","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> ds = Dataset(var1 = [1, 2, 3],\n                var2 = [1.2, 0.5, 3.3],\n                var3 = [\"C1\", \"C2\", \"C3\"])\n3×3 Dataset\n Row │ var1      var2      var3\n     │ identity  identity  identity\n     │ Int64?    Float64?  String?\n─────┼────────────────────────────────\n   1 │        1       1.2  C1\n   2 │        2       0.5  C2\n   3 │        3       3.3  C3","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The first line of the output provides the general information about the data set.  A data set is shown as a table in Julia, where each column represents a variable  in the data set. The header section of the table shows three pieces of information  for each column (variable), the column's name, the column's format, and  the column's data type. The format of a column controls how the values  of a column should be shown or interpreted when working with a data set.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The following example shows how to create a data set by providing a range of values.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> Dataset(A = 1:3, B = 5:7, fixed = 1)\n3×3 Dataset\n Row │ A         B         fixed\n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?\n─────┼──────────────────────────────\n   1 │        1         5         1\n   2 │        2         6         1\n   3 │        3         7         1","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Observe that using scalars for a column, like 1 for the column :fixed get automatically broadcasted to fill all rows of the created Dataset.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The missing values in Julia are declare as missing, and these values can also be an observation for a particular column, e.g.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> Dataset(a = [1.1, -10.0, missing], b = 1:3)\n3×2 Dataset\n Row │ a          b\n     │ identity   identity\n     │ Float64?   Int64?\n─────┼─────────────────────\n   1 │       1.1         1\n   2 │     -10.0         2\n   3 │ missing           3","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Sometimes one needs to create a data set whose column names are not valid Julia identifiers. In such a case the following form where column names are passed as strings, and = is replaced by => is handy:","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> Dataset(\"customer age\" => [15, 20, 25],\n                 \"first name\" => [\"Ben\", \"Steve\", \"Jule\"])\n3×2 Dataset\nRow │ customer age  first name\n    │ identity      identity\n    │ Int64?        String?\n────┼───────────────────────────\n  1 │           15  Ben\n  2 │           20  Steve\n  3 │           25  Jule","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"It is also possible to construct a data set from the values of a matrix or a vector of vectors, e.g.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> Dataset([1 0; 2 0], :auto)\n2×2 Dataset\n Row │ x1        x2\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │        1         0\n   2 │        2         0\n\njulia> Dataset([[1, 2], [0, 0]], :auto)\n2×2 Dataset\n Row │ x1        x2\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │        1         0\n   2 │        2         0","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Note that the column names are generated automatically when :auto is set as the second argument.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Alternatively you can pass a vector of column names as a second argument to the Dataset:","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> Dataset([1 0; 2 0], [:col1, :col2])\n2×2 Dataset\n Row │ col1      col2\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │        1         0\n   2 │        2         0","category":"page"},{"location":"man/basics/#Basic-utility-functions","page":"First Steps","title":"Basic utility functions","text":"","category":"section"},{"location":"man/basics/#Getting-meta-information-about-a-data-set","page":"First Steps","title":"Getting meta information about a data set","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"To get information about a data set, use the content function. It provides meta information about a data set.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> ds = Dataset(g = [1, 1, 1, 2, 2],\n                   x1_int = [0, 0, 1, missing, 2],\n                   x2_int = [3, 2, 1, 3, -2],\n                   x1_float = [1.2, missing, -1.0, 2.3, 10],\n                   x2_float = [missing, missing, 3.0, missing, missing],\n                   x3_float = [missing, missing, -1.4, 3.0, -100.0])\n5×6 Dataset\n Row │ g         x1_int    x2_int    x1_float   x2_float   x3_float\n     │ identity  identity  identity  identity   identity   identity\n     │ Int64?    Int64?    Int64?    Float64?   Float64?   Float64?\n─────┼───────────────────────────────────────────────────────────────\n   1 │        1         0         3        1.2  missing    missing\n   2 │        1         0         2  missing    missing    missing\n   3 │        1         1         1       -1.0        3.0       -1.4\n   4 │        2   missing         3        2.3  missing          3.0\n   5 │        2         2        -2       10.0  missing       -100.0\n\njulia> content(ds)\n5×6 Dataset\n   Created: 2021-08-04T13:11:53.743\n  Modified: 2021-08-04T13:11:53.743\n      Info:\n-----------------------------------\nColumns information\n┌─────┬──────────┬──────────┬─────────┐\n│ Row │ col      │ format   │ eltype  │\n├─────┼──────────┼──────────┼─────────┤\n│   1 │ g        │ identity │ Int64   │\n│   2 │ x1_int   │ identity │ Int64   │\n│   3 │ x2_int   │ identity │ Int64   │\n│   4 │ x1_float │ identity │ Float64 │\n│   5 │ x2_float │ identity │ Float64 │\n│   6 │ x3_float │ identity │ Float64 │\n└─────┴──────────┴──────────┴─────────┘","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"content shows that the data set has 5 rows and 6 columns. It also shows when the data set has been created and when is the last time that it has been modified. The content function also reports the data type and formats of each variable.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The Info field is a string field which can contain any information related to the data set. To set an Info for a data set, use setinfo!, e.g.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> setinfo!(ds, \"An example from the manual\")\n\"An example from the manual\"","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"This information will be attached to the data set ds. Use getinfo to enquiry this information.","category":"page"},{"location":"man/basics/#Setting-and-removing-formats","page":"First Steps","title":"Setting and removing formats","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"To set a specific format for a column of a data set use setformat! function, e.g.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> ds = Dataset(x = 1:10,\n                    y = repeat(1:5, inner = 2),\n                    z = repeat(1:2, 5))\n10×3 Dataset\n Row │ x         y         z\n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?\n─────┼──────────────────────────────\n   1 │        1         1         1\n   2 │        2         1         2\n   3 │        3         2         1\n   4 │        4         2         2\n   5 │        5         3         1\n   6 │        6         3         2\n   7 │        7         4         1\n   8 │        8         4         2\n   9 │        9         5         1\n  10 │       10         5         2\n\njulia> setformat!(ds, :y => sqrt)\n10×3 Dataset\n Row │ x         y        z\n     │ identity  sqrt     identity\n     │ Int64?    Int64?   Int64?\n─────┼─────────────────────────────\n   1 │        1  1.0             1\n   2 │        2  1.0             2\n   3 │        3  1.41421         1\n   4 │        4  1.41421         2\n   5 │        5  1.73205         1\n   6 │        6  1.73205         2\n   7 │        7  2.0             1\n   8 │        8  2.0             2\n   9 │        9  2.23607         1\n  10 │       10  2.23607         2","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The first argument for setformat! is the data set which needs to be modified and the second argument is the name of column, =>, and a named function. In the above example, we assign sqrt function as a format for the column :y.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Note that setformat! doesn't check the validity of a format, so if an invalid format is assigned to a column, for instance assigning sqrt to a column which contains negative values, some functionality of data set will be parallelised (like showing the data set). In these cases, simply remove the invalid format by using removeformat!.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Let's define a function as a new format for column :z in the above example,","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> function gender(x)\n          x == 1 ? \"Male\" : x == 2 ? \"Female\" : missing\n       end","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The format gender accepts one value and if the value is equal to 1, gender maps it to \"Male\", if the value is equal to 2, it maps it to \"Female\", and for any other values it maps them to missing.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> setformat!(ds, :z => gender)\n10×3 Dataset\n Row │ x         y        z\n     │ identity  sqrt     gender\n     │ Int64?    Int64?   Int64?\n─────┼───────────────────────────\n   1 │        1  1.0        Male\n   2 │        2  1.0      Female\n   3 │        3  1.41421    Male\n   4 │        4  1.41421  Female\n   5 │        5  1.73205    Male\n   6 │        6  1.73205  Female\n   7 │        7  2.0        Male\n   8 │        8  2.0      Female\n   9 │        9  2.23607    Male\n  10 │       10  2.23607  Female","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"the removeformat! function should be used to remove a column's format.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> removeformat!(ds, :y)\n10×3 Dataset\n Row │ x         y         z\n     │ identity  identity  gender\n     │ Int64?    Int64?    Int64?\n─────┼────────────────────────────\n   1 │        1         1    Male\n   2 │        2         1  Female\n   3 │        3         2    Male\n   4 │        4         2  Female\n   5 │        5         3    Male\n   6 │        6         3  Female\n   7 │        7         4    Male\n   8 │        8         4  Female\n   9 │        9         5    Male\n  10 │       10         5  Female","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Similar to setformat! the first argument is the name of the data set and the second argument is the name of the column(s) which we want to remove its(their) format(s). Note that assigning or removing a format doesn't change the actual values of the column.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"By default, formatted values of a column will be used when operations like displaying, sorting, grouping, or joining are called.","category":"page"},{"location":"man/basics/#Accessing-individual-column-or-observation","page":"First Steps","title":"Accessing individual column or observation","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"User must avoid using getindex and setindex! for modifying data sets, we just briefly discuss them here to make sure users understand the effect of these operations on data sets. InMemoryDatasets provides efficient APIs for modifying observations, e.g. see modify!, modify, map!, map, ...","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"ds[:, col], ds[i, col] can be used to access a specific column or specific observation of a specific column of ds, respectively. For example,","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> ds = Dataset(x = [4,6,3], y = [1,2,43]);\njulia> ds[:, :x]\n3-element Vector{Union{Missing, Int64}}:\n 4\n 6\n 3\n\njulia> ds[3, :y]\n43","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Note that ds[:, col] extracts (copies) a column of a data set as a vector. Thus, this vector can be used as a normal vector in Julia.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Also note that, assigning a new value to ds[3, :y] will modify the data set, i.e.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> ds[3, :y] = 3\n3\n\njulia> ds\n3×2 Dataset\n Row │ x         y\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │        4         1\n   2 │        6         2\n   3 │        3         3\n\njulia> content(ds)\n3×2 Dataset\n   Created: 2021-08-04T13:18:51.185\n  Modified: 2021-08-04T13:24:33.086\n      Info:\n-----------------------------------\nColumns information\n┌─────┬─────┬──────────┬────────┐\n│ Row │ col │ format   │ eltype │\n├─────┼─────┼──────────┼────────┤\n│   1 │ x   │ identity │ Int64  │\n│   2 │ y   │ identity │ Int64  │\n└─────┴─────┴──────────┴────────┘","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The content function shows that the data set has been created on 2021-08-04T13:18:51.185, and the last time that it has been modified is on 2021-08-04T13:24:33.086.","category":"page"},{"location":"man/basics/#Adding-and-removing-columns","page":"First Steps","title":"Adding and removing columns","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"To add a new column (variable) to a data set use the insertcols! function. The select function and its in-place counterpart select! can be used to drop columns from a data set. The select(select!) function is used to rearange columns, however, using Not(cols) can be used to select all columns except those which are wrapped in Not.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> ds = Dataset(var1 = [1, 2, 3])\n3×1 Dataset\n Row │ var1\n     │ identity\n     │ Int64?\n─────┼──────────\n   1 │        1\n   2 │        2\n   3 │        3\n\njulia> insertcols!(ds, :var2 => [\"val1\", \"val2\", \"val3\"])\n3×2 Dataset\n Row │ var1      var2\n     │ identity  identity\n     │ Int64?    String?\n─────┼──────────────────────\n   1 │        1  val1\n   2 │        2  val2\n   3 │        3  val3\n\njulia> insertcols!(ds, :var3 => [3.5, 4.6, 32.0])\n3×3 Dataset\n Row │ var1      var2        var3\n     │ identity  identity    identity\n     │ Int64?    String?     Float64?\n─────┼────────────────────────────────\n   1 │        1  val1             3.5\n   2 │        2  val2             4.6\n   3 │        3  val3            32.0\n\njulia> select!(ds, Not(:var2))\n3×2 Dataset\n Row │ var1      var3     \n     │ identity  identity \n     │ Int64?    Float64? \n─────┼────────────────────\n   1 │        1       3.5\n   2 │        2       4.6\n   3 │        3      32.0","category":"page"},{"location":"man/basics/#Converting-the-columns'-type","page":"First Steps","title":"Converting the columns' type","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"To convert the values of a column to another type, user can use the following syntax:","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"modify!(ds, col => byrow(T))","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"where ds is the input data set, col is the column which its values' type is going to be converted and T is the new type (the byrow function is discussed in Row-wise operations, and the modify! function is discussed in Transforming datasets). This functionality must be used in cases where each individual value needed to be converted. For scenarios that the convertion process needs the information of all values in a column, the byrow function must be dropped, e.g. modify!(ds, col => PooledArray). Additionally, user may allow Julia to find the most suitable type of a column by calling modify!(ds, col => byrow(identity)). In the following example we are using modify! to correct the type of columns in ds.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"Note that in the following example calling byrow(identity) on :y convert type Any to Integer. However, note that Integer is an abstract type and it will slow down the performance of operations on ds. To improve the performance of calculations, user may use modify!(ds, :y => byrow(Int)) instead.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> using PooledArrays\n\njulia> ds = Dataset(x = [missing,2,3,4], y = Any[1,missing,-1,true], z = [\"a\", \"bc\", \"a\", missing])\n4×3 Dataset\n Row │ x         y         z        \n     │ identity  identity  identity \n     │ Int64?    Any       String?  \n─────┼──────────────────────────────\n   1 │  missing  1         a\n   2 │        2  missing   bc\n   3 │        3  -1        a\n   4 │        4  true      missing  \n\njulia> modify!(ds, :x => byrow(Float64), :y => byrow(identity), :z => PooledArray)\n4×3 Dataset\n Row │ x          y         z        \n     │ identity   identity  identity \n     │ Float64?   Integer?  String?  \n─────┼───────────────────────────────\n   1 │ missing           1  a\n   2 │       2.0   missing  bc\n   3 │       3.0        -1  a\n   4 │       4.0      true  missing  \n\njulia> ds[:, :x]\n4-element Vector{Union{Missing, Float64}}:\n  missing\n 2.0\n 3.0\n 4.0\n\njulia> ds[:, :y]\n4-element Vector{Union{Missing, Integer}}:\n    1\n     missing\n   -1\n true\n\njulia> ds[:, :z]\n4-element PooledVector{Union{Missing, String}, UInt32, Vector{UInt32}}:\n \"a\"\n \"bc\"\n \"a\"\n missing","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"To convert the type of multiple columns at once, user may use the boradcasting technique:","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> using PooledArrays\n\njulia> ds = Dataset(x = [missing,2,3,4], y = Any[1,missing,-1,true], z = [\"a\", \"bc\", \"a\", missing])\n4×3 Dataset\n Row │ x         y         z        \n     │ identity  identity  identity \n     │ Int64?    Any       String?  \n─────┼──────────────────────────────\n   1 │  missing  1         a\n   2 │        2  missing   bc\n   3 │        3  -1        a\n   4 │        4  true      missing  \n\njulia> modify!(ds, [:x, :y] .=> byrow(Float64)) # note \".\" in \".=>\"\n4×3 Dataset\n Row │ x          y          z        \n     │ identity   identity   identity \n     │ Float64?   Float64?   String?  \n─────┼────────────────────────────────\n   1 │ missing          1.0  a\n   2 │       2.0  missing    bc\n   3 │       3.0       -1.0  a\n   4 │       4.0        1.0  missing  ","category":"page"},{"location":"man/basics/#Some-useful-functions","page":"First Steps","title":"Some useful functions","text":"","category":"section"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"The following functions are very handy when working with a data set, for more information look at the package documentation. Note that functions which end with ! modify the original data set.","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"names(ds) gives the column names as a vector of string.\nsize(ds) prints the data set dimension, i.e. number of rows and number of columns\nnrow(ds) returns the number of rows\nncol(ds) returns the number of columns\nfilter/filter! filter data based on byrow operation\nfirst(ds, n) shows the first n rows of a data set\nlast(ds, n) shows the last n rows of a data set\nrename/rename! can be used to rename column names\nselect/select! can be used to drop, select, or rearrange columns\ndeleteat! deletes rows from a data set\nappend!(ds, tds) appends tds at the end of ds\nrepeat/repeat! repeats rows of a dataset\nunique/unique! filter unique rows\nduplicates find duplicate rows","category":"page"},{"location":"man/basics/","page":"First Steps","title":"First Steps","text":"julia> test_data = Dataset(rand(1:10, 4, 3), :auto)\n4×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?\n─────┼──────────────────────────────\n   1 │        5        10         5\n   2 │        3         8        10\n   3 │        1         7         7\n   4 │        2         6         5\n\njulia> names(test_data)\n3-element Vector{String}:\n \"x1\"\n \"x2\"\n \"x3\"\n\njulia> size(test_data)\n(4, 3)\n\njulia> nrow(test_data)\n4\n\njulia> ncol(test_data)\n3\n\njulia> first(test_data, 3)\n3×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?\n─────┼──────────────────────────────\n   1 │        5        10         5\n   2 │        3         8        10\n   3 │        1         7         7\n\njulia> last(test_data, 2)\n2×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?\n─────┼──────────────────────────────\n   1 │        1         7         7\n   2 │        2         6         5\n\njulia> rename!(test_data, :x1 => :var1)\n4×3 Dataset\n Row │ var1      x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?\n─────┼──────────────────────────────\n   1 │        5        10         5\n   2 │        3         8        10\n   3 │        1         7         7\n   4 │        2         6         5\n\njulia> select!(test_data, :x2, :var1)\n4×2 Dataset\n Row │ x2        var1\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │       10         5\n   2 │        8         3\n   3 │        7         1\n   4 │        6         2\n\njulia> test_data\n4×2 Dataset\n Row │ x2        var1\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │       10         5\n   2 │        8         3\n   3 │        7         1\n   4 │        6         2\n\njulia> deleteat!(test_data, 2)\n3×2 Dataset\n Row │ x2        var1\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │       10         5\n   2 │        7         1\n   3 │        6         2\n\njulia> second_data = Dataset(var1 = [1, 3, 5, 6, 6],\n                             x2 = [3, 4,5,6, 3])\n5×2 Dataset\n Row │ var1      x2\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │        1         3\n   2 │        3         4\n   3 │        5         5\n   4 │        6         6\n   5 │        6         3\n\njulia> append!(test_data, second_data)\n8×2 Dataset\n Row │ x2        var1\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │       10         5\n   2 │        7         1\n   3 │        6         2\n   4 │        3         1\n   5 │        4         3\n   6 │        5         5\n   7 │        6         6\n   8 │        3         6","category":"page"},{"location":"man/performance/#Performance-tips","page":"Performance tips","title":"Performance tips","text":"","category":"section"},{"location":"man/performance/","page":"Performance tips","title":"Performance tips","text":"This section contains some performance tips which can improve the experience of working with InMemoryDatasets. These tips are specially important when the package is handling huge data.","category":"page"},{"location":"man/performance/#Make-use-of-provided-APIs","page":"Performance tips","title":"Make use of provided APIs","text":"","category":"section"},{"location":"man/performance/","page":"Performance tips","title":"Performance tips","text":"Every data manipulation, data cleaning, data wrangling should be done via the provided APIs, i.e. don't modify columns out of those APIs. For example, changing values of a column or creating a new column using a for loop must be done via modify!, modify or similar functions,","category":"page"},{"location":"man/performance/","page":"Performance tips","title":"Performance tips","text":"julia> ds = Dataset(x = [1,2,1,2], y = [1.5,3.4,-10,2.3])\n4×2 Dataset\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Float64?\n─────┼────────────────────\n   1 │        1       1.5\n   2 │        2       3.4\n   3 │        1     -10.0\n   4 │        2       2.3\n\njulia> function r_f!(x)\n           for i in 2:length(x)\n               if x[i-1] < 2.0\n                   x[i] = missing\n               end\n           end\n           x\n       end\nr_f! (generic function with 1 method)\n\njulia> modify!(groupby(ds, 1), :y=>r_f!)\n4×2 Dataset\n Row │ x         y         \n     │ identity  identity  \n     │ Int64?    Float64?  \n─────┼─────────────────────\n   1 │        1        1.5\n   2 │        2        3.4\n   3 │        1  missing   \n   4 │        2        2.3\n\njulia> map!(filter(ds, :x, by = ==(2), view = true), x->x+2, :x);\n\njulia> ds\n4×2 Dataset\n Row │ x         y         \n     │ identity  identity  \n     │ Int64?    Float64?  \n─────┼─────────────────────\n   1 │        1        1.5\n   2 │        4        3.4\n   3 │        1  missing   \n   4 │        4        2.3","category":"page"},{"location":"man/performance/#Avoid-pushing-single-values","page":"Performance tips","title":"Avoid pushing single values","text":"","category":"section"},{"location":"man/performance/","page":"Performance tips","title":"Performance tips","text":"This is because every single change in a data set will trigger multiple functions (InMemoryDatasets changes the modified date, whether the format should be dropped, ...) and the overhead will be significant.","category":"page"},{"location":"man/performance/#Avoid-using-String-type-for-large-data-sets","page":"Performance tips","title":"Avoid using String type for large data sets","text":"","category":"section"},{"location":"man/performance/","page":"Performance tips","title":"Performance tips","text":"String in julia causes significant Garbage Collection overhead. InMemoryDatasets needs to create many intermediate arrays during its operations and GC degrades its performance. Use PooledArrays or fixed width Strings for such scenarios.","category":"page"},{"location":"man/performance/#Choose-groupby-or-gatherby-based-on-the-problem-in-hand","page":"Performance tips","title":"Choose groupby or gatherby based on the problem in hand","text":"","category":"section"},{"location":"man/performance/","page":"Performance tips","title":"Performance tips","text":"Beside the order of the output, note that groupby and gatherby use very different approaches for grouping observations. groupby/! utilises the multithreading efficiently however, gatherby exploits the fast path of computations for some specific operations and usually has lower memory footprint.","category":"page"},{"location":"man/performance/","page":"Performance tips","title":"Performance tips","text":"InMemoryDatasets passes a copy of columns to combine when users pass a groupped data set created by groupby or gatherby as its first argument, thus, it is safe to mutate the columns in-place. However, when a groupped data set is created by groupby! then mutating in-place inside the combine function is not safe, because in this case, InMemoryDatasets passes the columns directly to combine.","category":"page"},{"location":"man/performance/#Beware-that-every-column-must-support-missings","page":"Performance tips","title":"Beware that every column must support missings","text":"","category":"section"},{"location":"man/performance/","page":"Performance tips","title":"Performance tips","text":"Every columns in InMemoryDatasets will be converted to support missing. Thus, it is wise to create the vectors in that way. For example, if you load an Arrow file which its columns don't support missing values, InMemoryDatasets materialises the whole file, but if they already support missing values, InMemoryDatasets uses the memory map for accessing values.","category":"page"},{"location":"man/performance/#Master-byrow","page":"Performance tips","title":"Master byrow","text":"","category":"section"},{"location":"man/performance/","page":"Performance tips","title":"Performance tips","text":"byrow uses efficient algorithms to apply functions on each row of a data set. It is fine tuned for some specific functions, which are listed in its docstring. And it is the core function for filtering observations, so mastering its capabilities is essential for working with data sets.","category":"page"},{"location":"man/performance/#Don't-avoid-for-loops!","page":"Performance tips","title":"Don't avoid for loops!","text":"","category":"section"},{"location":"man/performance/","page":"Performance tips","title":"Performance tips","text":"Julia is very fast program and users don't need to think about vectorisation for the sake of performance. Actually, using loop usually is a better choice and reduces the memory allocations. Thus, users don't need to avoid for loops and are encouraged to use them. However, remember to wrap your for loops in a function and pass the function to an appropriate API in InMemoryDatasets, e.g. modify!.","category":"page"},{"location":"man/filter/#Filter-observations","page":"Filter observations","title":"Filter observations","text":"","category":"section"},{"location":"man/filter/#Introduction","page":"Filter observations","title":"Introduction","text":"","category":"section"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"In this section, the InMemoryDatasets' APIs for filtering observations are discussed. We provides information about four main ways to filter observations based on some conditions, 1) using the byrow function, 2) using the mask function, 3) using the contains and related functions, 4) and using Julia broadcasting.","category":"page"},{"location":"man/filter/#byrow","page":"Filter observations","title":"byrow","text":"","category":"section"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"byrow has been discussed previously in details. However, in this section we are going to use it for filtering observations. To use byrow(ds, fun, cols, ...) for filtering observations, we set fun argument to all or any, and supply the conditions by using the by keyword option. The supplied by will be checked for each observation in all selected columns. The function returns a boolean vector where its jth elements will be equivalent to the result of all(by, [col1[j], col2[j], ...]) or any(by, [col1[j], col2[j], ...]) when all or any is set as the fun argument, respectively.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"The main feature of byrow(ds, fun, cols, by = ...) when fun is all/any is that the by keyword argument can be a vector of functions. Thus, when a multiple columns are supplied as cols each column can have its own by. To filter based on formatted value the mapformats keyword argument must be set to true.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"Naturally, other funs supported by byrow which return a Vector{Bool} or BitVector can be used to filter observations, too.","category":"page"},{"location":"man/filter/#filter-and-filter!","page":"Filter observations","title":"filter and filter!","text":"","category":"section"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"The filter function exploits the byrow function to filter a data set. Basically, it calls byrow(ds, type, cols; ...) to return a boolean vector which its true elements indicate the filtered rows, and subsequently, it calls findall and getindex to extract those filtered rows. Thus, user must pass a value to type which byrow(ds, type, cols; ...) returns a boolean vector (or a BitVector). ","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"If view = false a freshly allocated Dataset is returned, otherwise, a SubDataset view into ds is returned.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"The missings keyword argument controls how the missing values should be interpreted by filter. By default,  the missing values are left as missing, however, user can set it as false or true to force filter to interpret the missing values as false or true, respectively.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"Beside type and missings, any passed keyword arguments to filter will be passed to the corresponding byrow function. For a list of keyword arguments supported by a given type, see the help of byrow for that specific type, e.g. in Julia REPL type ?byrow(type) for a given type to see the documentation of the selected type.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"The following provides more details about type = all and type = any.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"type = all and type = any","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"When type = all (type = any), filter filters each row that all (any) of its values are true (testing by isequal). User can pass the keyword argument by to replace isequal with any other predicators. The by keyword argument can be a single function or a vector of functions. When a single function is passed to the by keyword argument, all columns use it as predicator, however, by passing a vector of functions, user can pass a separate predicator to each column. ","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"By default, when type is all or any, the filter function uses the actual values of each row, however, by passing mapformats = true, the formatted values will be used instead.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"Note that, multithreading is on by default for types all and any, thus, filter exploits all the cores available to Julia for performing the computations. User can pass threads = false to disable this feature.","category":"page"},{"location":"man/filter/#delete-and-delete!","page":"Filter observations","title":"delete and delete!","text":"","category":"section"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"The delete and delete! functions are similar to the filter and filter! functions, respectivley, however, instead of filtering rows, these functions remove the filtered rows.","category":"page"},{"location":"man/filter/#Examples","page":"Filter observations","title":"Examples","text":"","category":"section"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"The first expression creates a data set, and in the second one we use byrow to filter all rows which the values of all columns are equal to 1.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"julia> ds = Dataset(x1 = 1, x2 = 1:10, x3 = repeat(1:2, 5))\n10×3 Dataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        1         1         1\n   2 │        1         2         2\n   3 │        1         3         1\n   4 │        1         4         2\n   5 │        1         5         1\n   6 │        1         6         2\n   7 │        1         7         1\n   8 │        1         8         2\n   9 │        1         9         1\n  10 │        1        10         2\n\njulia> byrow(ds, all, :, by = isequal(1))\n10-element Vector{Bool}:\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"Note that only the first row is meeting the condition. As another example, let's see the code which filter all rows which the numbers in all columns are odd.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"julia> filter(ds, :, by = isodd)\n\n 5×3 Dataset\n  Row │ x1        x2        x3       \n      │ identity  identity  identity\n      │ Int64?    Int64?    Int64?   \n ─────┼──────────────────────────────\n    1 │        1         1         1\n    2 │        1         3         1\n    3 │        1         5         1\n    4 │        1         7         1\n    5 │        1         9         1","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"In the next example we are going to filter all rows which the value of any of column is greater than 5.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"julia> byrow(ds, any, :, by = >(5))\n10-element Vector{Bool}:\n 0\n 0\n 0\n 0\n 0\n 1\n 1\n 1\n 1\n 1","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"The next example shows how a vector of functions can be supplied:","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"julia> byrow(ds, all, 2:3, by = [>(5), isodd])\n10-element Vector{Bool}:\n 0\n 0\n 0\n 0\n 0\n 0\n 1\n 0\n 1\n 0","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"In the next example we pass the missings keyword argument:","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"julia> ds = Dataset(x = [2, 4, 6, missing], y = [1, 2, 3, 4])\n4×2 Dataset\n Row │ x         y        \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        2         1\n   2 │        4         2\n   3 │        6         3\n   4 │  missing         4\n\njulia> filter(ds, [:x, :y], by = iseven, missings = false)\n1×2 Dataset\n Row │ x         y        \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        4         2\n\njulia> filter(ds, [:x, :y], by = iseven, missings = true)\n2×2 Dataset\n Row │ x         y        \n     │ identity  identity \n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        4         2\n   2 │  missing         4","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"We can use the combination of modify!/modify and byrow to filter observations based on all values in a column, e.g. in the following example we filter all rows which :x2 and :x3 are larger than their means:","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"julia> modify!(ds, 2:3 .=> (x -> x .> mean(x)) .=> [:_tmp1, :_tmp2])\n10×5 Dataset\n Row │ x1        x2        x3        _tmp1     _tmp2    \n     │ identity  identity  identity  identity  identity\n     │ Int64?    Int64?    Int64?    Bool?     Bool?    \n─────┼──────────────────────────────────────────────────\n   1 │        1         1         1     false     false\n   2 │        1         2         2     false      true\n   3 │        1         3         1     false     false\n   4 │        1         4         2     false      true\n   5 │        1         5         1     false     false\n   6 │        1         6         2      true      true\n   7 │        1         7         1      true     false\n   8 │        1         8         2      true      true\n   9 │        1         9         1      true     false\n  10 │        1        10         2      true      true\n\njulia> filter(ds, r\"_tm\") # translate to ds[byrow(ds, all, r\"_tm\"), :]\n\n3×5 Dataset\nRow │ x1        x2        x3        _tmp1     _tmp2    \n    │ identity  identity  identity  identity  identity\n    │ Int64?    Int64?    Int64?    Bool?     Bool?    \n────┼──────────────────────────────────────────────────\n  1 │        1         6         2      true      true\n  2 │        1         8         2      true      true\n  3 │        1        10         2      true      true","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"Note that to drop the temporary columns we can use the select! function.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"In the following example we use different function for type. By passing type = isequal we filter observations which are equal for all columns in each row.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"julia> ds = Dataset(x1 = [1,2,3,1,2,3], x2 = [1,2,1,2,1,2])\n6×2 Dataset\n Row │ x1        x2       \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1         1\n   2 │        2         2\n   3 │        3         1\n   4 │        1         2\n   5 │        2         1\n   6 │        3         2\n\njulia> filter(ds, :, type = isequal)\n2×2 Dataset\n Row │ x1        x2       \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1         1\n   2 │        2         2","category":"page"},{"location":"man/filter/#mask","page":"Filter observations","title":"mask","text":"","category":"section"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"mask is a function which calls a function (or a vector of functions) on all observations of a set of selected columns. The syntax for mask is very similar to map function:","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"mask(ds, funs, cols, [mapformats = true, missings = false, threads = true])","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"however, unlike map, the function doesn't return the whole modified dataset, it returns a boolean data set with the same number of rows as ds and the same number of columns as the length of cols, while fun has been called on each observation. The return value of fun must be true, false, or missing. The combination of mask and byrow can be used to filter observations.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"Compared to filter/! (delete/!), the mask function has the following default behaviour:","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"mask returns a boolean data set which shows exactly which observation will be selected when fun is called on it.\nBy default, the mask function filters observations based on their formatted values. And to change this we should pass mapformats = false.\nBy default, the mask function will treat the missing values as false, however, this behaviour can be modified by using the keyword option missings. This option can be set as true, false(default value), or missing.","category":"page"},{"location":"man/filter/#Examples-2","page":"Filter observations","title":"Examples","text":"","category":"section"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"julia> ds = Dataset(x1 = repeat(1:2, 5), x2 = 1:10, x3 = repeat([missing, 2], 5))\n10×3 Dataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        1         1   missing\n   2 │        2         2         2\n   3 │        1         3   missing\n   4 │        2         4         2\n   5 │        1         5   missing\n   6 │        2         6         2\n   7 │        1         7   missing\n   8 │        2         8         2\n   9 │        1         9   missing\n  10 │        2        10         2\n\njulia> setformat!(ds, 2 => isodd)\n10×3 Dataset\nRow │ x1        x2      x3       \n    │ identity  isodd   identity\n    │ Int64?    Int64?  Int64?   \n────┼────────────────────────────\n  1 │        1    true   missing\n  2 │        2   false         2\n  3 │        1    true   missing\n  4 │        2   false         2\n  5 │        1    true   missing\n  6 │        2   false         2\n  7 │        1    true   missing\n  8 │        2   false         2\n  9 │        1    true   missing\n 10 │        2   false         2\n\njulia>  mask(ds, isequal(1), :) # simple use case\n10×3 Dataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity\n     │ Bool?     Bool?     Bool?    \n─────┼──────────────────────────────\n   1 │     true      true     false\n   2 │    false     false     false\n   3 │     true      true     false\n   4 │    false     false     false\n   5 │     true      true     false\n   6 │    false     false     false\n   7 │     true      true     false\n   8 │    false     false     false\n   9 │     true      true     false\n  10 │    false     false     false\n\njulia> _tmp = mask(ds, isequal(1), :, mapformats = false) # use the actual values instead of formatted values\n10×3 Dataset\nRow │ x1        x2        x3       \n    │ identity  identity  identity\n    │ Bool?     Bool?     Bool?    \n────┼──────────────────────────────\n  1 │     true      true     false\n  2 │    false     false     false\n  3 │     true     false     false\n  4 │    false     false     false\n  5 │     true     false     false\n  6 │    false     false     false\n  7 │     true     false     false\n  8 │    false     false     false\n  9 │     true     false     false\n 10 │    false     false     false\n\njulia> filter(_tmp, :, type = any) # OR ds[byrow(_tmp, any, :), :]. This uses the result of previous run\n5×3 Dataset\n Row │ x1        x2      x3       \n     │ identity  isodd   identity\n     │ Int64?    Int64?  Int64?   \n─────┼────────────────────────────\n   1 │        1    true   missing\n   2 │        1    true   missing\n   3 │        1    true   missing\n   4 │        1    true   missing\n   5 │        1    true   missing\n\njulia> mask(ds, [isodd, ==(2)], 2:3, missings = missing) # using a vector of functions and setting missings option\n10×2 Dataset\n Row │ x2        x3       \n     │ identity  identity\n     │ Bool?     Bool?    \n─────┼────────────────────\n   1 │     true   missing\n   2 │    false      true\n   3 │     true   missing\n   4 │    false      true\n   5 │     true   missing\n   6 │    false      true\n   7 │     true   missing\n   8 │    false      true\n   9 │     true   missing\n  10 │    false      true","category":"page"},{"location":"man/filter/#Using-contains-and-related-functions","page":"Filter observations","title":"Using contains and related functions","text":"","category":"section"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"Filtering a data set based on another data set should be done via contains, semijoin, semijoin!, antijoin, and antijoin! functions. These functions are discussed in the section about joining data sets, and here we just provide some examples about how to use them for filtering a data set.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"Additionally, these functions can be used in situations when a data set needed to be filter based on a set of values. In these cases, a temporary data set can be formed by given values and then one of the aforementioned functions can be used.","category":"page"},{"location":"man/filter/#Examples-3","page":"Filter observations","title":"Examples","text":"","category":"section"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"julia> ds1 = Dataset(x = [1,7,4,5], y = [.1,.2,.3,.4])\n4×2 Dataset\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Float64?\n─────┼────────────────────\n   1 │        1       0.1\n   2 │        7       0.2\n   3 │        4       0.3\n   4 │        5       0.4\n\njulia> ds2 = Dataset(x = [1,3,5,7,11])\n5×1 Dataset\n Row │ x        \n     │ identity\n     │ Int64?   \n─────┼──────────\n   1 │        1\n   2 │        3\n   3 │        5\n   4 │        7\n   5 │       11\n\njulia> contains(ds1,ds2, on = :x)\n4-element Vector{Bool}:\n 1\n 1\n 0\n 1\n\njulia> semijoin(ds1,ds2, on = :x)\n3×2 Dataset\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Float64?\n─────┼────────────────────\n   1 │        1       0.1\n   2 │        7       0.2\n   3 │        5       0.4\n\njulia> vals = [.05,.01,.1,.4];\n\njulia> _tmp = Dataset(vals = vals)\n4×1 Dataset\n Row │ vals     \n     │ identity\n     │ Float64?\n─────┼──────────\n   1 │     0.05\n   2 │     0.01\n   3 │     0.1\n   4 │     0.4\n\njulia> antijoin!(ds1, _tmp, on = :y=>:vals)\n2×2 Dataset\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Float64?\n─────┼────────────────────\n   1 │        7       0.2\n   2 │        4       0.3\n\njulia> ; Since vals is a vector we can directly use filter\n\njulia> ds1 = Dataset(x = [1,7,4,5], y = [.1,.2,.3,.4]);\n\njulia> filter!(ds1, :y, by = !in(Set(vals)))\n2×2 Dataset\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Float64?\n─────┼────────────────────\n   1 │        7       0.2\n   2 │        4       0.3","category":"page"},{"location":"man/filter/#Julia-broadcasting","page":"Filter observations","title":"Julia broadcasting","text":"","category":"section"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"Note that, in general, byrow, filter, or filter! are preferred methods to filter data sets compared to broadcasting","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"For simple use case (e.g. when working on a single column) we can use broadcasting directly. For example if we are interested in rows which the first column is greater than 5 we can directly use (assume the data set is called ds):","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"ds[ds[!, 1] .> 1, :]","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"or use the column names.","category":"page"},{"location":"man/filter/#Examples-4","page":"Filter observations","title":"Examples","text":"","category":"section"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"In the following examples we use . for broadcasting, and its important to include it in your code when you are going to use this option for filtering observations.","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"julia> ds = Dataset(x1 = repeat(1:2, 5), x2 = 1:10, x3 = repeat([missing, 2], 5))\n10×3 Dataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        1         1   missing\n   2 │        2         2         2\n   3 │        1         3   missing\n   4 │        2         4         2\n   5 │        1         5   missing\n   6 │        2         6         2\n   7 │        1         7   missing\n   8 │        2         8         2\n   9 │        1         9   missing\n  10 │        2        10         2\n\njulia> ds[ds.x1 .== 2, :]\n5×3 Dataset\nRow │ x1        x2        x3       \n    │ identity  identity  identity\n    │ Int64?    Int64?    Int64?   \n────┼──────────────────────────────\n  1 │        2         2         2\n  2 │        2         4         2\n  3 │        2         6         2\n  4 │        2         8         2\n  5 │        2        10         2\n\njulia> ds[(ds.x1 .== 1) .& (ds.x2 .> 5), :]\n2×3 Dataset\nRow │ x1        x2        x3       \n    │ identity  identity  identity\n    │ Int64?    Int64?    Int64?   \n────┼──────────────────────────────\n  1 │        1         7   missing\n  2 │        1         9   missing\n\njulia> using BenchmarkTools\n\njulia> ds = Dataset(rand(1:1000, 10^6, 10), :auto);\n\njulia> @btime ds[ds.x1 .== 100, :];\n  1.579 ms (480 allocations: 251.73 KiB)\n\njulia> @btime filter(ds, :x1, by = ==(100));\n  508.430 μs (568 allocations: 1.21 MiB)","category":"page"},{"location":"man/filter/#Related-functions","page":"Filter observations","title":"Related functions","text":"","category":"section"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"There are few other functions in InMemoryDatasets which can be used to filter observations. Those are","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"completecases\ndropmissing\ndropmissing!\nduplicates\nunique\nunique!","category":"page"},{"location":"man/filter/","page":"Filter observations","title":"Filter observations","text":"The completecases, dropmissing, dropmissing! functions use byrow to find or filter missing observations. The duplicates, unique, and unique! function can be used to filter duplicates rows in a data set.","category":"page"},{"location":"man/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"An extended version of this tutorial is available here.","category":"page"},{"location":"man/tutorial/#Getting-and-loading-the-data","page":"Tutorial","title":"Getting and loading the data","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"We recommend the DLMReader package to load a csv file into InMemoryDatasets, DLMReader is a high-performance and versatile package for reading delimited files into InMemoryDatasets (there are many alternative packages in Julia ecosystem, users can use any of them to read data into InMemoryDatasets):","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using InMemoryDatasets\n\njulia> using DLMReader\n\njulia> using PooledArrays\n\njulia> import Downloads\n\njulia> _tmp = Downloads.download(\"https://raw.githubusercontent.com/sl-solution/InMemoryDatasetsTutorial/main/CA_flights.csv\");\n\njulia> flights = filereader(_tmp, dtformat = Dict(1=>dateformat\"y-m-d\"));\n\njulia> modify!(flights, [:IATA, :Tail_Number, :Origin, :Dest, :CancellationCode] => PooledArray) # convert Strings to PooledArray for efficiency - We discuss the modify! function later\n\njulia> setinfo!(flights, \"Reporting Carrier On-Time Performance for all flights in 2020 from CA. Downloaded from www.transtats.bts.gov\");","category":"page"},{"location":"man/tutorial/#Filtering-the-data","page":"Tutorial","title":"Filtering the data","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In order to select only rows matching certain criteria, use the filter function. Note that for referring to a single column in a data set, we can use the column name (a Symbol), the column name as String, or the column index","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> filter(flights, :FlightDate, by = x->monthday(x)==(1,1))\n\njulia> filter(flights, 1, by = x->monthday(x)==(1,1), view = true) # creating a view of filtered observations","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"To test if one of two conditions is verified:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> filter(flights, :IATA, by = in((\"AA\", \"UA\")))","category":"page"},{"location":"man/tutorial/#Select:-pick-columns-by-name","page":"Tutorial","title":"Select: pick columns by name","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"You can use the select!/select functions to select a subset of columns, unlike select!, select makes a copy of data","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> select(flights, :DepTime, :ArrTime, :Flight_Number)\n467402×3 Dataset\n    Row │ DepTime   ArrTime   Flight_Number\n        │ identity  identity  identity      \n        │ Int64?    Int64?    Int64?        \n────────┼───────────────────────────────────\n      1 │     2354       820            988\n      2 │     2345       757            988\n      3 │     2350       825            988\n      4 │     2400       754            988\n      5 │     2355       757            988\n      6 │     2357       815            988\n      7 │     2350       759            988\n      8 │     2345       759            988\n      9 │     2149       604            988\n     10 │     2152       606            988\n   ⋮    │    ⋮         ⋮            ⋮\n 467393 │     1247      1538            326\n 467394 │     2150      2253             99\n 467395 │     1421      1549             67\n 467396 │     1237      1527            326\n 467397 │     1833      2017            598\n 467398 │     1326      1505            582\n 467399 │      657      1255            317\n 467400 │      706      1237            317\n 467401 │      842      1348            318\n 467402 │     1651      1759             25\n                         467382 rows omitted","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"InMemoryDatasets provides different ways for referring to multiple columns. For instance, let's select all columns between :FlightDate and :Dest as well as all columns containing \"Taxi\" or \"Delay\" in their names. Between selects columns between two specified extremes, and regular expressions can be used to select columns with specified patterns.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> select(flights, Between(:FlightDate, :Dest), r\"Taxi|Delay\")\n467402×10 Dataset\n    Row │ FlightDate  IATA      Tail_Number  Flight_Number  Origin    Dest      TaxiOut   TaxiIn    DepDelay  ArrDelay\n        │ identity    identity  identity     identity       identity  identity  identity  identity  identity  identity\n        │ Date?       String?   String?      Int64?         String?   String?   Float64?  Float64?  Float64?  Float64?\n────────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────\n      1 │ 2020-01-01  B6        N947JB                 988  LAX       BOS           26.0      14.0      -5.0      -2.0\n      2 │ 2020-01-02  B6        N987JT                 988  LAX       BOS           16.0       9.0     -14.0     -25.0\n      3 │ 2020-01-03  B6        N986JB                 988  LAX       BOS           24.0      17.0      -9.0       3.0\n      4 │ 2020-01-04  B6        N964JT                 988  LAX       BOS           16.0       1.0       1.0     -28.0\n      5 │ 2020-01-05  B6        N981JT                 988  LAX       BOS           22.0       8.0      -4.0     -25.0\n      6 │ 2020-01-06  B6        N961JT                 988  LAX       BOS           22.0      11.0      -2.0      -7.0\n      7 │ 2020-01-07  B6        N935JB                 988  LAX       BOS           20.0       2.0      -9.0     -23.0\n      8 │ 2020-01-08  B6        N947JB                 988  LAX       BOS           11.0       8.0     -14.0     -23.0\n      9 │ 2020-01-09  B6        N980JT                 988  LAX       BOS           13.0      15.0      -6.0     -13.0\n     10 │ 2020-01-10  B6        N968JT                 988  LAX       BOS           17.0       6.0      -3.0     -11.0\n   ⋮    │     ⋮          ⋮           ⋮             ⋮           ⋮         ⋮         ⋮         ⋮         ⋮         ⋮\n 467393 │ 2020-09-27  G4        314NV                  326  LAX       BOI            9.0       7.0      -8.0     -17.0\n 467394 │ 2020-09-25  G4        272NV                   99  SMX       LAS            6.0       7.0     -13.0     -22.0\n 467395 │ 2020-09-06  G4        307NV                   67  OAK       LAS           10.0       9.0      -1.0      -1.0\n 467396 │ 2020-09-06  G4        337NV                  326  LAX       BOI           11.0       4.0     -14.0     -24.0\n 467397 │ 2020-09-07  G4        247NV                  598  SCK       AZA           10.0       7.0      13.0      15.0\n 467398 │ 2020-09-20  G4        256NV                  582  SCK       AZA            5.0       8.0      -2.0      -5.0\n 467399 │ 2020-09-07  G4        318NV                  317  LAX       MEM           14.0      24.0      -3.0      12.0\n 467400 │ 2020-09-14  G4        318NV                  317  LAX       MEM            8.0      12.0       6.0      -9.0\n 467401 │ 2020-09-26  G4        328NV                  318  LAX       SGF           10.0       4.0     -18.0     -26.0\n 467402 │ 2020-09-11  G4        312NV                   25  FAT       LAS           11.0       4.0       6.0       6.0\n                                                                                                    467382 rows omitted","category":"page"},{"location":"man/tutorial/#Applying-several-operations","page":"Tutorial","title":"Applying several operations","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"There are several packages in Julia to apply several operations one after the other, here we demonstrate the Chain package.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's assume we want to select :IATA and :DepDelay columns and filter for delays over 60 minutes.  Here we assume we want a copy of the result (compared to view of the result). The @chain macro automatically fills the first argument of the chained functions, thus, flights becomes the first argument view, and the output of view becomes the first argument of filter. We passed missings = false to filter to drop those rows in flights where :DepDelay is missing.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Chain\n\njulia> delayed =  @chain flights begin\n                     view(:, [:IATA, :DepDelay])\n                     filter(:DepDelay, by = >(60), missings = false)\n                   end\n10614×2 Dataset\n   Row │ IATA      DepDelay\n       │ identity  identity\n       │ String?   Float64?\n───────┼────────────────────\n     1 │ B6           240.0\n     2 │ B6           164.0\n     3 │ B6            61.0\n     4 │ B6            93.0\n     5 │ B6            93.0\n     6 │ B6            92.0\n     7 │ B6            80.0\n     8 │ B6           101.0\n     9 │ B6            99.0\n    10 │ B6            70.0\n   ⋮   │    ⋮         ⋮\n 10605 │ OO            87.0\n 10606 │ OO           132.0\n 10607 │ OO           129.0\n 10608 │ OO            70.0\n 10609 │ OO            93.0\n 10610 │ OO            71.0\n 10611 │ OO           118.0\n 10612 │ OO           153.0\n 10613 │ OO           177.0\n 10614 │ OO            96.0\n          10594 rows omitted","category":"page"},{"location":"man/tutorial/#Reorder-rows","page":"Tutorial","title":"Reorder rows","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Select :IATA and :DepDelay columns while sorted by :DepDelay. Note that in the following code, flights[!, [:IATA, :DepDelay]] is equivalent to view(flights, :, [:IATA, :DepDelay]). Further notice that, by default, calling sort on a view of a data set creates a new data set, however, passing view = true creates a view of sorted values.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Note sort! and sort reorder observations instead of sorting observations by reference (i.e. view of sorted data), however, we can use groupby, the combination of sortperm and view, or pass a view of a data set and set view = true to create a sorting data set by reference.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> sort(flights[!, [:IATA, :DepDelay]], 2)\n467402×2 Sorted Dataset\n Sorted by: DepDelay\n    Row │ IATA      DepDelay  \n        │ identity  identity  \n        │ String?   Float64?  \n────────┼─────────────────────\n      1 │ OO            -66.0\n      2 │ OO            -61.0\n      3 │ G4            -49.0\n      4 │ OO            -47.0\n      5 │ WN            -40.0\n      6 │ OO            -40.0\n      7 │ B6            -40.0\n      8 │ UA            -35.0\n      9 │ UA            -35.0\n     10 │ B6            -35.0\n   ⋮    │    ⋮          ⋮\n 467394 │ OO        missing   \n 467395 │ OO        missing   \n 467396 │ OO        missing   \n 467397 │ OO        missing   \n 467398 │ OO        missing   \n 467399 │ G4        missing   \n 467400 │ G4        missing   \n 467401 │ G4        missing   \n 467402 │ G4        missing   \n           467383 rows omitted","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"or, in reverse order:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> sort(flights[!, [:IATA, :DepDelay]], 2, rev = true)","category":"page"},{"location":"man/tutorial/#Add-new-columns","page":"Tutorial","title":"Add new columns","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Use the modify! or modify (modify makes a copy of data) functions to add a column to an existing dataset. In the following example we calculate speed, by dividing distance by air time. Here, we multiply :Speed by 60 since :AirTime is in minutes - it is also recommended to define functions outside modify!, since they will be reusable and the second time you call them no compilation is needed.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> m2h(x) = 60x\njulia> modify!(flights, [:Distance, :AirTime] => byrow(/) => :Speed, :Speed => byrow(m2h))","category":"page"},{"location":"man/tutorial/#Applying-functions-on-each-group-of-observations","page":"Tutorial","title":"Applying functions on each group of observations","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"To get the average delay for each destination, we groupby our data set by :Dest (if the order of original data set should be preserved, we must use gatherby), select :ArrDelay and compute the mean:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> combine(groupby(flights, :Dest), :ArrDelay => IMD.mean)\n120×2 Dataset\n Row │ Dest      mean_ArrDelay\n     │ identity  identity      \n     │ String?   Float64?      \n─────┼─────────────────────────\n   1 │ ABQ           -6.77667\n   2 │ ACV           -3.12598\n   3 │ ANC           -2.45455\n   4 │ ASE           14.446\n   5 │ ATL           -4.97706\n   6 │ AUS           -6.76768\n   7 │ AZA           16.3775\n   8 │ BDL           -2.16667\n   9 │ BFL           -2.35662\n  10 │ BIL           -7.04651\n  ⋮  │    ⋮            ⋮\n 111 │ SLC           -2.27623\n 112 │ SMF           -9.57659\n 113 │ SNA           -8.61454\n 114 │ STL           -7.94696\n 115 │ STS           -4.18345\n 116 │ SUN           -5.41912\n 117 │ TPA          -11.1995\n 118 │ TUL           -2.94444\n 119 │ TUS           -5.57618\n 120 │ XNA          -13.3143\n               100 rows omitted","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"we can summarise several columns at the same time, e.g. for each carrier, calculate the minimum and maximum arrival and departure delays:(Note that in the following code, r\"Delay\" => [IMD.minimum, IMD.maximum] is normalised as names(flights, r\"Delay\") .=> Ref([IMD.minimum, IMD.maximum]))","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> @chain flights begin\n           groupby(:IATA)\n           combine(r\"Delay\" => [IMD.minimum, IMD.maximum])\n        end\n14×5 Dataset\n Row │ IATA      minimum_DepDelay  maximum_DepDelay  minimum_ArrDelay  maximum_ArrDelay\n     │ identity  identity          identity          identity          identity         \n     │ String?   Float64?          Float64?          Float64?          Float64?         \n─────┼──────────────────────────────────────────────────────────────────────────────────\n   1 │ AA                   -29.0            2466.0             -75.0            2457.0\n   2 │ AS                   -34.0             590.0             -92.0             603.0\n   3 │ B6                   -40.0            1076.0             -91.0            1074.0\n   4 │ DL                   -28.0            1154.0             -75.0            1157.0\n   5 │ F9                   -34.0             372.0             -69.0             353.0\n   6 │ G4                   -49.0            1516.0             -60.0            1511.0\n   7 │ HA                   -22.0             659.0             -80.0             620.0\n   8 │ MQ                   -22.0            1223.0             -48.0            1223.0\n   9 │ NK                   -34.0            1339.0             -63.0            1160.0\n  10 │ OO                   -66.0            1531.0             -77.0            1528.0\n  11 │ UA                   -35.0            1182.0             -80.0            1185.0\n  12 │ WN                   -40.0             421.0             -84.0             415.0\n  13 │ YV                   -30.0            1170.0             -74.0            1165.0\n  14 │ YX                   -13.0             147.0             -22.0             136.0","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"For each day of the year, count the total number of flights and sort in descending order:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> @chain flights begin\n           setformat!(1 => day) # format date as day\n           gatherby(1)\n           combine(1 => length => :count)\n           sort!(2, rev = true)\n        end\n31×2 Sorted Dataset\n Sorted by: count\n Row │ FlightDate  count    \n     │ day         identity\n     │ Date?       Int64?   \n─────┼──────────────────────\n   1 │ 3              15981\n   2 │ 6              15975\n   3 │ 2              15845\n   4 │ 13             15827\n   5 │ 20             15802\n   6 │ 23             15757\n   7 │ 27             15727\n   8 │ 10             15672\n   9 │ 9              15670\n  10 │ 5              15661\n  ⋮  │     ⋮          ⋮\n  23 │ 8              15015\n  24 │ 29             15007\n  25 │ 14             14776\n  26 │ 18             14771\n  27 │ 11             14749\n  28 │ 25             14693\n  29 │ 15             14591\n  30 │ 30             13455\n  31 │ 31              9071\n             12 rows omitted","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"For each month of the year, calculate the cancellation rate:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> pct_fmt(x) = string(round(x*100, digits = 2), \"%\") # we use this as format for displaying values\n\njulia> @chain flights begin\n           setformat!(1 => month)\n           groupby(:FlightDate)\n           combine(:Cancelled => mean => :Percent)\n           setformat!(:Percent => pct_fmt)\n       end\n12×2 Dataset\n Row │ FlightDate  Percent  \n     │ month       pct_fmt  \n     │ Date?       Float64?\n─────┼──────────────────────\n   1 │ 1              0.94%\n   2 │ 2              0.75%\n   3 │ 3             17.58%\n   4 │ 4             44.05%\n   5 │ 5              5.21%\n   6 │ 6              0.27%\n   7 │ 7              0.63%\n   8 │ 8              0.68%\n   9 │ 9              0.47%\n  10 │ 10             0.21%\n  11 │ 11             0.35%\n  12 │ 12             0.77%","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"For each destination, count the total number of flights and the number of distinct planes that flew there","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> @chain flights begin\n          groupby(:Dest)\n          combine(:Tail_Number .=> [length, length∘union] .=> [:Count, :Unique_Flight])\n        end\n120×3 Dataset\n Row │ Dest      Count     Unique_Flight\n     │ identity  identity  identity      \n     │ String?   Int64?    Int64?        \n─────┼───────────────────────────────────\n   1 │ ABQ           1861            684\n   2 │ ACV           1097            202\n   3 │ ANC            135             67\n   4 │ ASE            823             77\n   5 │ ATL           9604           1323\n   6 │ AUS           4678           1527\n   7 │ AZA            232             42\n   8 │ BDL             13             12\n   9 │ BFL            297            137\n  10 │ BIL             44             16\n  ⋮  │    ⋮         ⋮            ⋮\n 111 │ SLC          19590           1755\n 112 │ SMF          13750           1186\n 113 │ SNA           7908           1077\n 114 │ STL           2371            777\n 115 │ STS           1025            122\n 116 │ SUN            295             97\n 117 │ TPA            401            254\n 118 │ TUL             83             14\n 119 │ TUS           2272            743\n 120 │ XNA            106             57\n                         100 rows omitted","category":"page"},{"location":"man/tutorial/#Non-reduction-functions","page":"Tutorial","title":"Non-reduction functions","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"In the previous section, we always applied functions that reduced a vector to a single value. Non-reduction functions instead take a vector and return a vector. For example we can rank, within each :IATA, how much delay a given flight had and figure out the day and month with the two greatest delays: (Note that for using a multivariate function in combine, the input columns must be passed as Tuple)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> most_delay(x, y) = x[topkperm(y, 2)]\njulia> @chain flights begin\n         groupby(:IATA)\n         combine((:FlightDate, :DepDelay) => most_delay => :Most_Delay)\n         setformat!(2 => monthday)\n       end\n28×2 Dataset\n Row │ IATA      Most_Delay\n     │ identity  monthday   \n     │ String?   Date?      \n─────┼──────────────────────\n   1 │ AA        (3, 7)\n   2 │ AA        (8, 7)\n   3 │ AS        (1, 22)\n   4 │ AS        (10, 11)\n   5 │ B6        (2, 9)\n   6 │ B6        (5, 4)\n   7 │ DL        (10, 8)\n   8 │ DL        (6, 29)\n   9 │ F9        (2, 3)\n  10 │ F9        (1, 2)\n  ⋮  │    ⋮          ⋮\n  19 │ OO        (1, 10)\n  20 │ OO        (1, 12)\n  21 │ UA        (1, 20)\n  22 │ UA        (1, 3)\n  23 │ WN        (10, 26)\n  24 │ WN        (9, 17)\n  25 │ YV        (3, 6)\n  26 │ YV        (1, 31)\n  27 │ YX        (2, 1)\n  28 │ YX        (2, 7)\n              8 rows omitted","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"We could use Julia partial sorting too.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"performance tip: If you'll group often by the same column(s), you can use groupby! or sort! functions to sort your data set by that column(s) at once to optimise future computations. The difference between groupby! and sort! is that the former one sorts and marks data as grouped, but the latter one only sorts data.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"For each month, calculate the number of flights and the change from the previous month","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> @chain flights begin\n          setformat!(1 => month)\n          groupby(1)\n          combine(1 => length => :length)\n          modify!(:length => (x-> x .- lag(x)) => :change)\n      end\n12×3 Dataset\n Row │ FlightDate  length    change   \n     │ month       identity  identity\n     │ Date?       Int64?    Int64?   \n─────┼────────────────────────────────\n   1 │ 1              66748   missing\n   2 │ 2              62504     -4244\n   3 │ 3              69172      6668\n   4 │ 4              31285    -37887\n   5 │ 5              16940    -14345\n   6 │ 6              22278      5338\n   7 │ 7              33648     11370\n   8 │ 8              34476       828\n   9 │ 9              29825     -4651\n  10 │ 10             32100      2275\n  11 │ 11             33700      1600\n  12 │ 12             34726      1026","category":"page"},{"location":"man/tutorial/#Visualising-your-data","page":"Tutorial","title":"Visualising your data","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"The StatsPlots, VegaLite, Makie packages (among others) make a rich set of visualisations possible with an intuitive syntax.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Here we use StatisticalGraphics.jl to visualise the cancellation rate in busiest airports for each month:","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using StatisticalGraphics\njulia> @chain flights begin\n          filter!(:Origin, by = in([\"LAX\", \"SFO\", \"SAN\"]))\n      \n          sgplot(\n                Bar(y=:FlightDate, response=:Cancelled, stat=IMD.mean,\n                        group=:Origin, groupdisplay=:cluster),\n                yaxis=Axis(title=\"Month\", order=:ascending),\n                xaxis=Axis(title=\"Rate\", d3format=\"%\", grid=true, gridcolor=:white, domain=false),\n                wallcolor=:lightgray)\n       end","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: cancellation)","category":"page"},{"location":"man/tutorial/#Exporting-data","page":"Tutorial","title":"Exporting data","text":"","category":"section"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"You can use the JLD2.jl package to export the data set with meta information into a JLD2 file.","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using JLD2\njulia> content(flights)\n467402×17 Dataset\n   Created: 2022-08-09T16:04:51.122\n  Modified: 2022-08-09T16:05:03.822\n      Info: Reporting Carrier On-Time Performance for all flights in 2020 from CA. Downloaded from www.transtats.bts.gov\n-----------------------------------\nColumns information \n┌─────┬──────────────────┬──────────┬─────────┐\n│ Row │ col              │ format   │ eltype  │\n├─────┼──────────────────┼──────────┼─────────┤\n│   1 │ FlightDate       │ month    │ Date    │\n│   2 │ IATA             │ identity │ String  │\n│   3 │ Tail_Number      │ identity │ String  │\n│   4 │ Flight_Number    │ identity │ Int64   │\n│   5 │ Origin           │ identity │ String  │\n│   6 │ Dest             │ identity │ String  │\n│   7 │ TaxiOut          │ identity │ Float64 │\n│   8 │ TaxiIn           │ identity │ Float64 │\n│   9 │ DepDelay         │ identity │ Float64 │\n│  10 │ ArrDelay         │ identity │ Float64 │\n│  11 │ DepTime          │ identity │ Int64   │\n│  12 │ ArrTime          │ identity │ Int64   │\n│  13 │ AirTime          │ identity │ Float64 │\n│  14 │ Cancelled        │ identity │ Float64 │\n│  15 │ CancellationCode │ identity │ String  │\n│  16 │ Distance         │ identity │ Float64 │\n│  17 │ Speed            │ identity │ Float64 │\n└─────┴──────────────────┴──────────┴─────────┘\n\njulia> @save \"flights.jld2\" flights\njulia> @load \"flights.jld2\" flights\n1-element Vector{Symbol}:\n :flights\n\njulia> content(flights)\n467402×17 Dataset\n   Created: 2022-08-09T16:04:51.122\n  Modified: 2022-08-09T16:05:03.822\n      Info: Reporting Carrier On-Time Performance for all flights in 2020 from CA. Downloaded from www.transtats.bts.gov\n-----------------------------------\nColumns information \n┌─────┬──────────────────┬──────────┬─────────┐\n│ Row │ col              │ format   │ eltype  │\n├─────┼──────────────────┼──────────┼─────────┤\n│   1 │ FlightDate       │ month    │ Date    │\n│   2 │ IATA             │ identity │ String  │\n│   3 │ Tail_Number      │ identity │ String  │\n│   4 │ Flight_Number    │ identity │ Int64   │\n│   5 │ Origin           │ identity │ String  │\n│   6 │ Dest             │ identity │ String  │\n│   7 │ TaxiOut          │ identity │ Float64 │\n│   8 │ TaxiIn           │ identity │ Float64 │\n│   9 │ DepDelay         │ identity │ Float64 │\n│  10 │ ArrDelay         │ identity │ Float64 │\n│  11 │ DepTime          │ identity │ Int64   │\n│  12 │ ArrTime          │ identity │ Int64   │\n│  13 │ AirTime          │ identity │ Float64 │\n│  14 │ Cancelled        │ identity │ Float64 │\n│  15 │ CancellationCode │ identity │ String  │\n│  16 │ Distance         │ identity │ Float64 │\n│  17 │ Speed            │ identity │ Float64 │\n└─────┴──────────────────┴──────────┴─────────┘","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"Also, you can use DLMReader package to write an AbstractDataset as text to a file using a given delimiter (which defaults to comma).","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using DLMReader\njulia> filewriter(\"flights.csv\", flights)","category":"page"},{"location":"man/tutorial/","page":"Tutorial","title":"Tutorial","text":"To write the formatted values, you need to use filewriter with mapformats = true option. For more information, see ?filewriter.","category":"page"},{"location":"man/sorting/#Sorting-Datasets","page":"Sort","title":"Sorting Datasets","text":"","category":"section"},{"location":"man/sorting/#Introduction","page":"Sort","title":"Introduction","text":"","category":"section"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"Sorting is one of the key tasks for Datasets. Actually, when we group a data set by given set of columns, InMemoryDatasets does sorting behind the scene and groups the observations based on their sorted values. The joining algorithms also uses the sorting functions for finding the matched observations. One may sort a data set based on a set of columns by either their formatted values, or their actual values. In this section we go through the main functions for sorting Datasets.","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"Note that, by default, InMemoryDatasets uses parallel algorithms for sorting observations. User may stop parallel sorting by passing threads = false.","category":"page"},{"location":"man/sorting/#sort!/sort","page":"Sort","title":"sort!/sort","text":"","category":"section"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"The sort! function accepts a Dataset and a set of columns and sorts the given Dataset based on provided columns. By default the sort! function does the sorting based on the formatted values, however, using mapformats = false forces the sorting be done based on the actual values. sort! doesn't create a new dataset, it only replaces the original one with the sorted one. If the original data set needed to be untouched the sort function must be used. By default, both sort! and sort functions do a stable sort using a hybrid Heap sort algorithm. If the stability of the sort is not needed, using the keyword option stable = false can improve the performance. User can also change the default sorting algorithm to hybrid QuickSort by using the alg = QuickSort option. For most problems QuickSort algorithm is faster than the default algorithm, however, its worst case scenario is slower than the default algorithm.","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"By default the ascending sorting is used for the sorting task, and using rev = true changes it to descending ordering, and for multiple columns a vector of  true, false can be supplied for this option, i.e. each column can be sorted in ascending or descending order independently. Note that:","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"Datasets uses isless for checking the order of values.\nDatasets prints extra information when it shows a sorted data set.\nLike Julia Base, the missing values are treated larger than any other values.\nsort creates a copy of data and permutes each column of it and attaches some attributes to the new data set. To sort a data set without creating a new data set or modifying the original data set, someone may use the groupby function. The groupby function sorts and then creates a meta information about the sorted data set. The groupby function will be discussed in another section in detail.","category":"page"},{"location":"man/sorting/#Examples","page":"Sort","title":"Examples","text":"","category":"section"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"julia> ds = Dataset(x = [5,4,3,2,1], y = [42,52,4,1,55])\n5×2 Dataset\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        5        42\n   2 │        4        52\n   3 │        3         4\n   4 │        2         1\n   5 │        1        55\n\njulia> sort!(ds, :x);\njulia> ds\n5×2 Sorted Dataset\n Sorted by: x\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1        55\n   2 │        2         1\n   3 │        3         4\n   4 │        4        52\n   5 │        5        42\n\njulia> sort(ds, :y, rev = true)\n5×2 Sorted Dataset\n Sorted by: y\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1        55\n   2 │        4        52\n   3 │        5        42\n   4 │        3         4\n   5 │        2         1\n\njulia> ds = Dataset(x = [5, 4, missing, 4],\n                    y = [3, missing, missing , 1])\n4×2 Dataset\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        5         3\n   2 │        4   missing\n   3 │  missing   missing\n   4 │        4         1\n\njulia> sort(ds, 1:2)\n4×2 Sorted Dataset\n Sorted by: x, y\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        4         1\n   2 │        4   missing\n   3 │        5         3\n   4 │  missing   missing\n\njulia> sort(ds, 1:2, rev = [false, true])\n4×2 Sorted Dataset\n Sorted by: x, y\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        4   missing\n   2 │        4         1\n   3 │        5         3\n   4 │  missing   missing","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"The following examples show how the sorting functions work with formats.","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"julia> ds = Dataset(state = [\"CA\", \"TX\", \"IL\", \"IL\", \"IL\", \"CA\", \"TX\", \"TX\"],\n                    date = [Date(\"2020-01-01\"), Date(\"2020-03-01\"), Date(\"2020-01-01\"),\n                            Date(\"2020-03-01\"), Date(\"2020-02-01\"), Date(\"2021-03-01\"),\n                            Date(\"2021-02-01\"), Date(\"2020-02-01\")],\n                      qt = [123, 143, 144, 199, 153, 144, 134, 188])\n8×3 Dataset\n Row │ state     date        qt       \n     │ identity  identity    identity\n     │ String?   Date?       Int64?   \n─────┼────────────────────────────────\n   1 │ CA        2020-01-01       123\n   2 │ TX        2020-03-01       143\n   3 │ IL        2020-01-01       144\n   4 │ IL        2020-03-01       199\n   5 │ IL        2020-02-01       153\n   6 │ CA        2021-03-01       144\n   7 │ TX        2021-02-01       134\n   8 │ TX        2020-02-01       188\n\njulia> setformat!(ds, :date=>month)\n8×3 Dataset\n Row │ state     date   qt       \n     │ identity  month  identity\n     │ String?   Date?  Int64?   \n─────┼───────────────────────────\n   1 │ CA        1           123\n   2 │ TX        3           143\n   3 │ IL        1           144\n   4 │ IL        3           199\n   5 │ IL        2           153\n   6 │ CA        3           144\n   7 │ TX        2           134\n   8 │ TX        2           188\n\njulia> sort(ds, [2,1])\n8×3 Sorted Dataset\n Sorted by: date, state\n Row │ state     date   qt       \n     │ identity  month  identity\n     │ String?   Date?  Int64?   \n─────┼───────────────────────────\n   1 │ CA        1           123\n   2 │ IL        1           144\n   3 │ IL        2           153\n   4 │ TX        2           134\n   5 │ TX        2           188\n   6 │ CA        3           144\n   7 │ IL        3           199\n   8 │ TX        3           143\n\njulia> sort(ds, [2,1], mapformats = false)\n8×3 Sorted Dataset\n Sorted by: date, state\n Row │ state     date   qt       \n     │ identity  month  identity\n     │ String?   Date?  Int64?   \n─────┼───────────────────────────\n   1 │ CA        1           123\n   2 │ IL        1           144\n   3 │ IL        2           153\n   4 │ TX        2           188\n   5 │ IL        3           199\n   6 │ TX        3           143\n   7 │ TX        2           134\n   8 │ CA        3           144\n\njulia> sort(ds, [1,2], mapformats = false)\n8×3 Sorted Dataset\n Sorted by: state, date\n Row │ state     date   qt       \n     │ identity  month  identity\n     │ String?   Date?  Int64?   \n─────┼───────────────────────────\n   1 │ CA        1           123\n   2 │ CA        3           144\n   3 │ IL        1           144\n   4 │ IL        2           153\n   5 │ IL        3           199\n   6 │ TX        2           188\n   7 │ TX        3           143\n   8 │ TX        2           134","category":"page"},{"location":"man/sorting/#sortperm","page":"Sort","title":"sortperm","text":"","category":"section"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"The sortperm(ds, cols) function returns a permutation vector perm that puts ds[perm, :] in sorted order based on cols. Similar to sort!/sort, this function accepts rev, alg, mapformats and stable options.","category":"page"},{"location":"man/sorting/#Examples-2","page":"Sort","title":"Examples","text":"","category":"section"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"julia> ds = Dataset(x = [1,4,3,2,1], y = [420,52,4,1,55])\n5×2 Dataset\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1       420\n   2 │        4        52\n   3 │        3         4\n   4 │        2         1\n   5 │        1        55\n\njulia> p = sortperm(ds, [1,2])\n5-element Vector{Int32}:\n5\n1\n4\n3\n2\n\njulia> ds[p, :]\n5×2 Dataset\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1        55\n   2 │        1       420\n   3 │        2         1\n   4 │        3         4\n   5 │        4        52","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"In the following example we show the performance difference between the default algorithm and QuickSort algorithm for sorting Integers.","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"julia> ds = Dataset(x = rand(Int, 10^8));\njulia> @time sortperm(ds,1, stable = false);\n 21.663503 seconds (604 allocations: 2.887 GiB, 0.11% gc time)\njulia> @time sortperm(ds,1, stable = false, alg = QuickSort);\n 4.818334 seconds (591 allocations: 2.887 GiB, 7.05% gc time)","category":"page"},{"location":"man/sorting/#unsort!","page":"Sort","title":"unsort!","text":"","category":"section"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"The unsort! function undo the last sort operation that has been done on a data set, i.e. when a sort! function has been applied to a data set, directly or indirectly (e.g. the groupby! function is one of the functions which uses sort! behind the scene), the unsort! function can undo it.","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"julia> ds = Dataset(x = [1,3,1,2,6,1,4,4],\n                    y = [100,150,90,110,100,80,50,30])\n8×2 Dataset\nRow │ x         y        \n    │ identity  identity\n    │ Int64?    Int64?   \n────┼────────────────────\n  1 │        1       100\n  2 │        3       150\n  3 │        1        90\n  4 │        2       110\n  5 │        6       100\n  6 │        1        80\n  7 │        4        50\n  8 │        4        30\n\njulia> sort!(ds, 1:2);\njulia> ds\n8×2 Sorted Dataset\n Sorted by: x, y\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1        80\n   2 │        1        90\n   3 │        1       100\n   4 │        2       110\n   5 │        3       150\n   6 │        4        30\n   7 │        4        50\n   8 │        6       100\n\njulia> unsort!(ds)\n8×2 Dataset\n Row │ x         y        \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1       100\n   2 │        3       150\n   3 │        1        90\n   4 │        2       110\n   5 │        6       100\n   6 │        1        80\n   7 │        4        50\n   8 │        4        30","category":"page"},{"location":"man/sorting/#issorted/issorted!","page":"Sort","title":"issorted/issorted!","text":"","category":"section"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"The issorted function checks if a data set is sorted by given column(s). The syntax for the function is issorted(ds, cols), and by default the mapformats keyword argument is set to true and the rev keyword argument is set to false. The issorted! function does the same job, however, if it returns true it marks the input data set as a sorted data set, i.e. it attaches some meta information to the data set.","category":"page"},{"location":"man/sorting/#Examples-3","page":"Sort","title":"Examples","text":"","category":"section"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"julia> ds = Dataset(x1 = [1, 4, 7], x2 = [3.0, 1.1, -10.0], x3 = [\"one\", \"two\", \"three\"])\n3×3 Dataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity\n     │ Int64?    Float64?  String?  \n─────┼──────────────────────────────\n   1 │        1       3.0  one\n   2 │        4       1.1  two\n   3 │        7     -10.0  three\n\njulia> issorted(ds, 1)\ntrue\n\njulia> issorted(ds, 2)\nfalse\n\njulia> issorted(ds, 2, rev = true)\ntrue\n\njulia> fmt(x) = x == \"one\" ? 1 : x==\"two\" ? 2 : 3\nfmt (generic function with 1 method)\n\njulia> setformat!(ds, :x3=>fmt)\n3×3 Dataset\n Row │ x1        x2        x3      \n     │ identity  identity  fmt     \n     │ Int64?    Float64?  String?\n─────┼─────────────────────────────\n   1 │        1       3.0  1\n   2 │        4       1.1  2\n   3 │        7     -10.0  3\n\njulia> issorted(ds, 3)\ntrue\n\njulia> issorted!(ds, 1:3, rev = [false, true, false])\ntrue\n\njulia> ds\n3×3 Sorted Dataset\n Sorted by: x1, x2, x3\n Row │ x1        x2        x3      \n     │ identity  identity  fmt     \n     │ Int64?    Float64?  String?\n─────┼─────────────────────────────\n   1 │        1       3.0  1\n   2 │        4       1.1  2\n   3 │        7     -10.0  3","category":"page"},{"location":"man/sorting/#Performance-improvement-using-formats","page":"Sort","title":"Performance improvement using formats","text":"","category":"section"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"In some scenarios the performance of sort can be improved by using formats. For example, when we know for a specific column there is only a few numbers after the decimal point, using a format can improve the performance of the sort. In the following example we are using the @btime macro from the BenchmarkTools package to demonstrate this;","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"julia> ;# column :x1 has at most 2 digits after the decimal point\njulia> ds = Dataset(x1 = round.(rand(10^6),digits = 2),\n               x2 = repeat(1:100, 10^4));\njulia> @btime sortperm(ds, 1);\n  37.169 ms (751 allocations: 31.53 MiB)\n\njulia> custom_fmt(x) = round(x * 100);\n\njulia> setformat!(ds, 1=>custom_fmt);\n\njulia> @btime sortperm(ds, 1);\n  5.678 ms (317 allocations: 17.19 MiB)","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"The 6 times improvement in the performance is due to the fact that the formatted values in the data set are basically integer rather than float (the actual values) and the algorithms for sorting integers are usually faster than those for sorting double precision numbers.","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"This can be generalised to situations where the numbers after the decimal point is not known, e.g. suppose we have the following data set","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"julia> ds = Dataset(x = rand(10^6))","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"in this case we cannot use the round trick directly, however, we can create an alias of :x and partially apply round trick on alias column and sort the data set based on both columns,","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"julia> fmt(x) = round(Int, x*100) # split data up to 100 parts\njulia> modify!(ds, :x => identity => :_tmp) # alias of :x - This is an instance operation\njulia> setformat!(ds, :_tmp=>fmt)\njulia> @btime sortperm(ds, [:x], alg = QuickSort); # without using formats\n  36.460 ms (508 allocations: 29.60 MiB)\n\njulia> @btime sortperm(ds, [:_tmp, :x], alg = QuickSort);\n  17.550 ms (505 allocations: 25.79 MiB)","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"This works because the second method exploits integer and float sorting algorithms and also utilises multiple cpus more efficiently.","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"Another trick can be used for situations when a data set contains a column of string values where the values can be treated as numbers, e.g. in the following code :x1 is basically integer values with \"id\" been attached to each value, here we use a customised format that extracts the numeric values from :x1;","category":"page"},{"location":"man/sorting/","page":"Sort","title":"Sort","text":"julia> ds = Dataset(x1 = \"id\" .* string.(rand(1:100000, 10^6)));\njulia> @btime sortperm(ds, 1);\n  257.070 ms (580 allocations: 27.70 MiB)\n\njulia> custom_fmt(x) = parse(Int, @views x[3:end])\ncustom_fmt (generic function with 1 method)\n\njulia> setformat!(ds, 1=>custom_fmt);\n\njulia> @btime sortperm(ds, 1);\n  15.456 ms (278 allocations: 17.57 MiB)","category":"page"},{"location":"man/grouping/#Group-observations","page":"Group observations","title":"Group observations","text":"","category":"section"},{"location":"man/grouping/#Introduction","page":"Group observations","title":"Introduction","text":"","category":"section"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"InMemoryDatasets uses two approaches to group observations: sorting, and hashing. In sorting approach, it sorts the data set based on given columns and finds the starts and ends of each group based on the sorted values. In hashing approach, it uses a hybrid algorithm to group observations. Each of these approaches has some advantages over the other one and for any particular problem one of them might be more suitable than the other one.","category":"page"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"By default, the functions for grouping observations exploits all core available to Julia for group observations, however, passing threads = false change this.","category":"page"},{"location":"man/grouping/#groupby!-and-groupby","page":"Group observations","title":"groupby! and groupby","text":"","category":"section"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"The main functions for grouping observations based on sorting approach are groupby! and groupby. The groupby! function replaces the original data set with the sorted one and attaches a meta information about the grouping orders to the replaced data set, on the other hand, the groupby function performs the sorting phase, however, it creates a view of the main data set where the meta information is attached to it. The output of groupby is basically a view of the sorted data set.","category":"page"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"The syntax for calling groupby! and groupby is the same as the sort! function. This means groupby! and groupby accept all keyword arguments that the sort! function supports, these include:","category":"page"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"rev with default value of false\nmapformats with default value of true, i.e. by default these functions group data sets based on the formatted values.\nstable with default value of true\nalg which by default is set to HeapSortAlg, and it can be set as QuickSort too.","category":"page"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"Removing formats of columns that are used for groupby! with mapformats = true removes the grouping information too, i.e. the data set will not be marked as grouped/sorted data set .","category":"page"},{"location":"man/grouping/#Examples","page":"Group observations","title":"Examples","text":"","category":"section"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"julia> ds = Dataset(g = [1, 2, 1, 2, 1, 2], x = [12.0, 12.3, 11.0, 13.0, 15.0, 13.2])\n6×2 Dataset\n Row │ g         x        \n     │ identity  identity\n     │ Int64?    Float64?\n─────┼────────────────────\n   1 │        1      12.0\n   2 │        2      12.3\n   3 │        1      11.0\n   4 │        2      13.0\n   5 │        1      15.0\n   6 │        2      13.2\n\njulia> groupby!(ds, 1)\n6×2 Grouped Dataset with 2 groups\nGrouped by: g\n Row │ g         x        \n     │ identity  identity\n     │ Int64?    Float64?\n─────┼────────────────────\n   1 │        1      12.0\n   2 │        1      11.0\n   3 │        1      15.0\n   4 │        2      12.3\n   5 │        2      13.0\n   6 │        2      13.2\n\njulia> ds # ds has been replaced with its grouped version\n6×2 Grouped Dataset with 2 groups\nGrouped by: g\n Row │ g         x        \n     │ identity  identity\n     │ Int64?    Float64?\n─────┼────────────────────\n   1 │        1      12.0\n   2 │        1      11.0\n   3 │        1      15.0\n   4 │        2      12.3\n   5 │        2      13.0\n   6 │        2      13.2\n\njulia> ds = Dataset(group = [\"c1\", \"c2\", \"c1\", \"c3\", \"c1\", \"c3\"], x = 1:6)\n6×2 Dataset\n Row │ group     x        \n     │ identity  identity\n     │ String?   Int64?   \n─────┼────────────────────\n   1 │ c1               1\n   2 │ c2               2\n   3 │ c1               3\n   4 │ c3               4\n   5 │ c1               5\n   6 │ c3               6\n\njulia> groupby(ds, :group)\n6×2 View of Grouped Dataset, Grouped by: group\n group     x        \n identity  identity\n String?   Int64?   \n────────────────────\n c1               1\n c1               3\n c1               5\n c2               2\n c3               4\n c3               6\n\njulia> ds # ds is untouched\n6×2 Dataset\n Row │ group     x        \n     │ identity  identity\n     │ String?   Int64?   \n─────┼────────────────────\n   1 │ c1               1\n   2 │ c2               2\n   3 │ c1               3\n   4 │ c3               4\n   5 │ c1               5\n   6 │ c3               6\njulia> salary = Dataset(id = 1:10,\n                       salary=[100, 120, 301, 95, 200, 75, 150, 67, 90, 110])\n10×2 Dataset\n Row │ id        salary   \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1       100\n   2 │        2       120\n   3 │        3       301\n   4 │        4        95\n   5 │        5       200\n   6 │        6        75\n   7 │        7       150\n   8 │        8        67\n   9 │        9        90\n  10 │       10       110\n\njulia> s_grp(x) = x < 100 ? 1 : x < 200 ? 2 : 3\ns_grp (generic function with 1 method)\n\njulia> setformat!(salary, :salary => s_grp)\n10×2 Dataset\n Row │ id        salary\n     │ identity  s_grp  \n     │ Int64?    Int64?\n─────┼──────────────────\n   1 │        1       2\n   2 │        2       2\n   3 │        3       3\n   4 │        4       1\n   5 │        5       3\n   6 │        6       1\n   7 │        7       2\n   8 │        8       1\n   9 │        9       1\n  10 │       10       2\n\njulia> groupby(salary, 2)\n10×2 View of Grouped Dataset, Grouped by: salary\n id        salary\n identity  s_grp  \n Int64?    Int64?\n──────────────────\n        4       1\n        6       1\n        8       1\n        9       1\n        1       2\n        2       2\n        7       2\n       10       2\n        3       3\n        5       3\n\njulia> ds = Dataset(x=[1,1,2,2], y=[1,2,1,2], z=[1,1,1,1])\n\njulia> groupby!(ds, [:x, :y]) # groupby by more than one column\n4×3 Grouped Dataset with 4 groups\nGrouped by: x, y\n Row │ x         y         z        \n     │ identity  identity  identity \n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        1         1         1\n   2 │        1         2         1\n   3 │        2         1         1\n   4 │        2         2         1\n","category":"page"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"The groupby! and groupby functions accept the output of the groupby function. Thus, some may use these functions to incrementally group a data set.","category":"page"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"When the groupby! function is used on a data set, the data set is marked as a grouped data set and the functions which handle grouped data set differently are signalled when the grouped data sets are passed as their arguments. Two of those functions are modify! and modify functions. When a grouped data set is passed to these two functions, InMemoryDatasets applies each modification within each group. The modify! and modify functions treat the view of a grouped data set (produced by the groupby function) in the same way without changing the order of the original data set. For better performance, set stable = false when the groupby function is used in conjunction with modify! or modify.","category":"page"},{"location":"man/grouping/#Examples-2","page":"Group observations","title":"Examples","text":"","category":"section"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"julia> ds = Dataset(g = [2, 1, 1, 2, 2],\n                          x1_int = [0, 0, 1, missing, 2],\n                          x2_int = [3, 2, 1, 3, -2],\n                          x1_float = [1.2, missing, -1.0, 2.3, 10],\n                          x2_float = [missing, missing, 3.0, missing, missing],\n                          x3_float = [missing, missing, -1.4, 3.0, -100.0])\n5×6 Dataset\n Row │ g         x1_int    x2_int    x1_float   x2_float   x3_float  \n     │ identity  identity  identity  identity   identity   identity  \n     │ Int64?    Int64?    Int64?    Float64?   Float64?   Float64?  \n─────┼───────────────────────────────────────────────────────────────\n   1 │        2         0         3        1.2  missing    missing   \n   2 │        1         0         2  missing    missing    missing   \n   3 │        1         1         1       -1.0        3.0       -1.4\n   4 │        2   missing         3        2.3  missing          3.0\n   5 │        2         2        -2       10.0  missing       -100.0\n\njulia> groupby!(ds, 1)\n5×6 Grouped Dataset with 2 groups\nGrouped by: g\n Row │ g         x1_int    x2_int    x1_float   x2_float   x3_float  \n     │ identity  identity  identity  identity   identity   identity  \n     │ Int64?    Int64?    Int64?    Float64?   Float64?   Float64?  \n─────┼───────────────────────────────────────────────────────────────\n   1 │        1         0         2  missing    missing    missing   \n   2 │        1         1         1       -1.0        3.0       -1.4\n   3 │        2         0         3        1.2  missing    missing   \n   4 │        2   missing         3        2.3  missing          3.0\n   5 │        2         2        -2       10.0  missing       -100.0\n\njulia> modify(ds, r\"int\" => x -> x .- IMD.maximum(x))\n5×6 Grouped Dataset with 2 groups\nGrouped by: g\n Row │ g         x1_int    x2_int    x1_float   x2_float   x3_float  \n     │ identity  identity  identity  identity   identity   identity  \n     │ Int64?    Int64?    Int64?    Float64?   Float64?   Float64?  \n─────┼───────────────────────────────────────────────────────────────\n   1 │        1        -1         0  missing    missing    missing   \n   2 │        1         0        -1       -1.0        3.0       -1.4\n   3 │        2        -2         0        1.2  missing    missing   \n   4 │        2   missing         0        2.3  missing          3.0\n   5 │        2         0        -5       10.0  missing       -100.0\n\njulia> sale = Dataset(date = [Date(2012, 11), Date(2013, 5), Date(2012, 4),\n                                     Date(2013, 1), Date(2014, 8), Date(2013, 2)],\n                             sale = [100, 200, 140, 200, 132, 150])\n6×2 Dataset\n Row │ date        sale     \n     │ identity    identity\n     │ Date?       Int64?   \n─────┼──────────────────────\n   1 │ 2012-11-01       100\n   2 │ 2013-05-01       200\n   3 │ 2012-04-01       140\n   4 │ 2013-01-01       200\n   5 │ 2014-08-01       132\n   6 │ 2013-02-01       150\n\njulia> setformat!(sale, :date=>year)\n6×2 Dataset\n Row │ date   sale     \n     │ year   identity\n     │ Date?  Int64?   \n─────┼─────────────────\n   1 │ 2012        100\n   2 │ 2013        200\n   3 │ 2012        140\n   4 │ 2013        200\n   5 │ 2014        132\n   6 │ 2013        150\n\njulia> spct(x) = x ./ IMD.sum(x) .* 100\nspct (generic function with 1 method)\n\njulia> modify(groupby(sale, :date), :sale => spct => :sale_pct)\n6×3 Dataset\n Row │ date   sale      sale_pct\n     │ year   identity  identity\n     │ Date?  Int64?    Float64?\n─────┼───────────────────────────\n   1 │ 2012        100   41.6667\n   2 │ 2013        200   36.3636\n   3 │ 2012        140   58.3333\n   4 │ 2013        200   36.3636\n   5 │ 2014        132  100.0\n   6 │ 2013        150   27.2727","category":"page"},{"location":"man/grouping/#ungroup!","page":"Group observations","title":"ungroup!","text":"","category":"section"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"The ungroup! function is a utility function that removes the grouped mark from a grouped data set produced by groupby!. The function doesn't change the permutation of the data set, thus, even the data set is not any more grouped, it is still sorted, and it is very efficient to re-group it. However, note that the last modified time of the data set is updated when ungroup! is called on a data set.","category":"page"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"The ungroup! function can be used in scenarios that one needs to modify a data set but it is not desired to apply a specific modification within each group, instead the modification is needed to be applied to the whole column. In these kind of situations, first ungroup! is used to remove the grouping mark and then the modify! function can be used on the data set. The groupby! function can be used afterward to mark the data set as grouped data set.","category":"page"},{"location":"man/grouping/#gatherby","page":"Group observations","title":"gatherby","text":"","category":"section"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"The gatherby function uses the hashing approach to group observations based on a set of columns. InMemoryDatasets uses a hybrid algorithm to gather observations which sometimes does this without using the hash function. The gatherby function doesn't sort the data set, instead, it uses the hybrid algorithm to group observations. gatherby can be particularly useful when sorting is computationally expensive. Another benefit of gatherby is that, by default, it keeps the order of observations in each group the same as their appearance in the original data set.","category":"page"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"The gatherby function uses the formatted values for gathering the observations into groups, however, using mapformats = false changes this behaviour.","category":"page"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"The syntax for using the gatherby function is gatherby(ds, cols) where ds is the data set and cols is any column selector which indicates the columns which are going to be used in gathering.","category":"page"},{"location":"man/grouping/#Examples-3","page":"Group observations","title":"Examples","text":"","category":"section"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"julia> ds = Dataset(grp = [1, 2, 3, 3, 1, 3, 2, 1],\n                  x = [true, false, true, true, true, true, false, false])\n8×2 Dataset\n Row │ grp       x        \n     │ identity  identity\n     │ Int64?    Bool?    \n─────┼────────────────────\n   1 │        1      true\n   2 │        2     false\n   3 │        3      true\n   4 │        3      true\n   5 │        1      true\n   6 │        3      true\n   7 │        2     false\n   8 │        1     false\n\njulia> gatherby(ds, :x)\n8×2 View of GatherBy Dataset, Gathered by: x\n grp       x        \n identity  identity\n Int64?    Bool?    \n────────────────────\n        1      true\n        3      true\n        3      true\n        1      true\n        3      true\n        2     false\n        2     false\n        1     false\n\njulia> setformat!(ds, 1=>isodd)\n8×2 Dataset\n Row │ grp     x        \n     │ isodd   identity\n     │ Int64?  Bool?    \n─────┼──────────────────\n   1 │   true      true\n   2 │  false     false\n   3 │   true      true\n   4 │   true      true\n   5 │   true      true\n   6 │   true      true\n   7 │  false     false\n   8 │   true     false\n\njulia> gatherby(ds, 1)\n8×2 View of GatherBy Dataset, Gathered by: grp\n grp     x        \n isodd   identity\n Int64?  Bool?    \n──────────────────\n   true      true\n   true      true\n   true      true\n   true      true\n   true      true\n   true     false\n  false     false\n  false     false","category":"page"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"Similar to groupby!/groupby functions, gatherby can be passed to functions which operate on grouped data sets.","category":"page"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"As mentioned before, the result of gatherby is stable, i.e. the observations order within each group will be the order of their appearance in the original data set. However, when this stability is not needed and there are many groups in the data set, passing stable = false improves the performance by sacrificing the stability.","category":"page"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"The gatherby function has two extra keyword arguments, isgathered and eachrow, which by default are set to false. When the isgathered argument is set to true, InMemoryDatasets assumes that the observations are currently gathered by some rules and it only finds the starts and ends of each group and marks the data set as gathered. So users can manually group observations by setting this keyword argument. When the eachrow argument is set to true, InMemoryDatasets does the gathering and then mark each row of the input data set as an individual group. This option is handy for transposing data sets.","category":"page"},{"location":"man/grouping/#Iterate-eachgroup","page":"Group observations","title":"Iterate eachgroup","text":"","category":"section"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"User can use eachgroup to iterate each group of a grouped data set. Each element of eachgroup is a SubDataset.","category":"page"},{"location":"man/grouping/#Examples-4","page":"Group observations","title":"Examples","text":"","category":"section"},{"location":"man/grouping/","page":"Group observations","title":"Group observations","text":"julia> ds = Dataset(rand(1:10, 10, 3), :auto)\n10×3 Dataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity \n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        7         8        10\n   2 │        4         1         5\n   3 │        7         2         5\n   4 │        4         7         4\n   5 │        5         9         6\n   6 │        9         5         3\n   7 │        9         8         2\n   8 │        7         9         6\n   9 │        2         3         8\n  10 │        1         6         2\n\njulia> i_gds = eachgroup(groupby(ds, 1));\n\njulia> map(nrow, i_gds)\n6-element Vector{Int64}:\n 1\n 1\n 2\n 1\n 3\n 2\n\njulia> i_gds[1]\n1×3 SubDataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity \n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        1         6         2\n\njulia> i_gds[end]\n2×3 SubDataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity \n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        9         5         3\n   2 │        9         8         2","category":"page"},{"location":"man/joins/#Joins-and-related-topics","page":"Joins","title":"Joins and related topics","text":"","category":"section"},{"location":"man/joins/#Introduction","page":"Joins","title":"Introduction","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"In this section we give details of the functions that can be used to combined data sets in InMemoryDatasets. These functions are multi-threaded (unless threads = false i s passed to the functions) and thus are very performant for general use. By default, InMemoryDatasets uses the formatted values for joining observations, however, this can be controlled by the mapformats keyword argument.","category":"page"},{"location":"man/joins/#Database-like-joins","page":"Joins","title":"Database like joins","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"The main functions for combining two data sets are leftjoin, innerjoin, outerjoin, semijoin, and antijoin. The basic syntax for all of these functions is *join(dsl, dsr, on = [...]), where dsl is the left data set, dsr is the right data set, and the on keyword argument specifies the key(s) which will be used for matching observations between the left and the right data set. In general, the on key can be a single column name (either as Symbol or String) or a vector of column names. When the column names are not identical in both tables, a vector of pair of column names can be used instead.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"leftjoin: joins two data sets and its output contains rows for values of the key(s) that exist in the left data set,   whether or not that value exists in the right data set.\ninnerjoin: joins two data sets and its output contains rows for values of the key(s) that exist in both left and right data sets.\nouterjoin: joins two data sets and its output contains rows for values of the key(s) that exist in any of the left or the right data set.\nsemijoin: Like an inner join, but its output is restricted to columns from the left table.\nantijoin: The output contains rows for values of the key(s) that exist in the left data set but not the right data set.   As with semijoin, output is restricted to columns from the left data set.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"See the Wikipedia page on SQL joins for more information.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"By default (except for semijoin and antijoin), to match observations, InMemoryDatasets sorts the right data set and uses a binary search algorithm for finding the matches of each observation in the left data set in the right data set based on the passed key column(s), thus, it has better performance when the left data set is larger than the right data set. However, passing method = :hash changes the default. The matching is done based on the formatted values of the key column(s), however, using the mapformats keyword argument can change this behaviour, one may set it to false for one or both data sets.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"For method = :sort and leftjoin and innerjoin the order of observations of the output data set is the same as their order in the left data set. However, the order of observations from the right table depends on the stability of the sort algorithm. User can set the stable keyword argument to true to guarantee a stable sort. For outerjoin the order of observations from the left data set in the output data set is also the same as their order in the original data set, however, for those observations which are from the right table when method = :sort there is no specific order.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"By default, when method = :sort, the join functions use a hybrid Heap Sort algorithm to sort the observations in the right data set, however, setting alg = QuickSort change the default algorithm to a hybrid Quick Sort one.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"For very large data sets, if the sorting of the first key is expensive, setting the accelerate keyword argument to true may improve the overall performance. By setting accelerate = true, InMemoryDatasets first divides all observations in the right data set into multiple parts (up to 1024 parts) based on the first passed key, and then for each observations in the left data set finds the corresponding part in the right data set and searches for the matching observations only within that part.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"The leftjoin, semijoin, and antijoin functions have in-place version which are leftjoin!, semijoin!, and antijoin!, respectively. Instead of creating a new output dataset, these in-place versions of the functions replace the passed left table. Note that, for the leftjoin! there must be no more than one match for each observation from the right table, otherwise, the function raises an error.","category":"page"},{"location":"man/joins/#Examples","page":"Joins","title":"Examples","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> name = Dataset(ID = [1, 2, 3], Name = [\"John Doe\", \"Jane Doe\", \"Joe Blogs\"])\n3×2 Dataset\n Row │ ID        Name      \n     │ identity  identity  \n     │ Int64?    String?   \n─────┼─────────────────────\n   1 │        1  John Doe\n   2 │        2  Jane Doe\n   3 │        3  Joe Blogs\n\njulia> job = Dataset(ID = [1, 2, 2, 4],\n                     Job = [\"Lawyer\", \"Doctor\", \"Florist\", \"Farmer\"])\n4×2 Dataset\n Row │ ID        Job      \n     │ identity  identity\n     │ Int64?    String?  \n─────┼────────────────────\n   1 │        1  Lawyer\n   2 │        2  Doctor\n   3 │        2  Florist\n   4 │        4  Farmer\n\njulia> leftjoin(name, job, on = :ID)\n4×3 Dataset\n Row │ ID        Name       Job      \n     │ identity  identity   identity\n     │ Int64?    String?    String?  \n─────┼───────────────────────────────\n   1 │        1  John Doe   Lawyer\n   2 │        2  Jane Doe   Doctor\n   3 │        2  Jane Doe   Florist\n   4 │        3  Joe Blogs  missing  \n\njulia> dsl = Dataset(year = [Date(\"2020-3-1\"), Date(\"2021-10-21\"), Date(\"2020-1-4\"), Date(\"2012-12-11\")],\n                     leap_year = [true, false, true, true])\n4×2 Dataset\n Row │ year        leap_year\n     │ identity    identity  \n     │ Date?       Bool?     \n─────┼───────────────────────\n   1 │ 2020-03-01       true\n   2 │ 2021-10-21      false\n   3 │ 2020-01-04       true\n   4 │ 2012-12-11       true\n\njulia> dsr = Dataset(year = [2020, 2021], event = ['A', 'B'])\n2×2 Dataset\n Row │ year      event    \n     │ identity  identity\n     │ Int64?    Char?    \n─────┼────────────────────\n   1 │     2020  A\n   2 │     2021  B\n\njulia> setformat!(dsl, 1 => year);\n\njulia> leftjoin(dsl, dsr, on = :year)\n4×3 Dataset\n Row │ year   leap_year  event    \n     │ year   identity   identity\n     │ Date?  Bool?      Char?    \n─────┼────────────────────────────\n   1 │ 2020        true  A\n   2 │ 2021       false  B\n   3 │ 2020        true  A\n   4 │ 2012        true  missing  \n\njulia> innerjoin(name, job, on = :ID)\n3×3 Dataset\n Row │ ID        Name      Job      \n     │ identity  identity  identity\n     │ Int64?    String?   String?  \n─────┼──────────────────────────────\n   1 │        1  John Doe  Lawyer\n   2 │        2  Jane Doe  Doctor\n   3 │        2  Jane Doe  Florist\n\njulia> outerjoin(name, job, on = :ID)\n5×3 Dataset\n Row │ ID        Name       Job      \n     │ identity  identity   identity\n     │ Int64?    String?    String?  \n─────┼───────────────────────────────\n   1 │        1  John Doe   Lawyer\n   2 │        2  Jane Doe   Doctor\n   3 │        2  Jane Doe   Florist\n   4 │        3  Joe Blogs  missing  \n   5 │        4  missing    Farmer","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"To demonstrate the use of the accelerate keyword, we generate two data sets and use the @btime macro from the BenchmarkTools package to benchmark the performance of the innerjoin function with and without acceleration.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> using BenchmarkTools\n\njulia> using Random\n\njulia> dsl = Dataset(x1 = [randstring('a':'z', 6) for _ in 1:10^6],\n               x2 = rand(1:100, 10^6), x3 = rand(10^6));\n\njulia> dsr = Dataset(y1 = [randstring('a':'z', 6) for _ in 1:10^6],\n               y2 = rand(1:100, 10^6), y3 = rand(10^6));\n\njulia> @btime innerjoin(dsl, dsr, on = [:x1=>:y1, :x2=>:y2]);\n  382.759 ms (1254 allocations: 55.40 MiB)\n\njulia> @btime innerjoin(dsl, dsr, on = [:x1=>:y1, :x2=>:y2], accelerate = true);\n  155.306 ms (2160 allocations: 45.92 MiB)","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"As it can be observed, using accelerate = true significantly reduces the joining time. The reason for this reduction is because currently sorting String type columns in InMemoryDatasets is relatively expensive, and using accelerate = true helps to reduce this by splitting the observations into multiple parts.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"And of course for this example we can simply use the hash techniques for matching observations:","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> @btime innerjoin(dsl, dsr, on = [:x1=>:y1, :x2=>:y2], method = :hash);\n 86.323 ms (1095 allocations: 96.95 MiB)","category":"page"},{"location":"man/joins/#contains","page":"Joins","title":"contains","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"The contains function is special function that can be used to enquiry observations of a data set which are contained in another data set. It returns a boolean vector where is true when the key for the corresponding row in the main data set is found in the transaction data set. The syntax of the function is the same as the leftjoin function. When a single column is used for matching observations, the function uses hashing techniques to find the matched observations, however, for multiple key columns, it uses the sorting algorithm to search for the matched observations.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"Both semijoin and antijoin use the contains function behind the scene for filtering the left data set.","category":"page"},{"location":"man/joins/#Close-match-join","page":"Joins","title":"Close match join","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"The closejoin function joins two data sets based on exact match on the key variable or the closest match (here, closest match depends on the direction keyword argument) when the exact match doesn't exist.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"The closejoin! function does a close join in-place.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"A tolerance for finding close matches can be passed via the tol keyword argument, and for the situations where the exact match is not allowed, user can pass allow_exact_match = false.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"closejoin/! support method = :hash however, for the last key column it uses the sorting method to find the closest match.","category":"page"},{"location":"man/joins/#Examples-2","page":"Joins","title":"Examples","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> classA = Dataset(id = [\"id1\", \"id2\", \"id3\", \"id4\", \"id5\"],\n                        mark = [50, 69.5, 45.5, 88.0, 98.5])\n5×2 Dataset\n Row │ id          mark\n     │ identity    identity\n     │ String?     Float64?\n─────┼──────────────────────\n   1 │ id1             50.0\n   2 │ id2             69.5\n   3 │ id3             45.5\n   4 │ id4             88.0\n   5 │ id5             98.5\njulia> grades = Dataset(mark = [0, 49.5, 59.5, 69.5, 79.5, 89.5, 95.5],\n                        grade = [\"F\", \"P\", \"C\", \"B\", \"A-\", \"A\", \"A+\"])\n7×2 Dataset\n Row │ mark      grade\n     │ identity  identity\n     │ Float64?  String?\n─────┼──────────────────────\n   1 │      0.0  F\n   2 │     49.5  P\n   3 │     59.5  C\n   4 │     69.5  B\n   5 │     79.5  A-\n   6 │     89.5  A\n   7 │     95.5  A+\n\njulia> closejoin(classA, grades, on = :mark)\n5×3 Dataset\n Row │ id          mark      grade\n     │ identity    identity  identity\n     │ String?     Float64?  String?\n─────┼──────────────────────────────────\n   1 │ id1             50.0  P\n   2 │ id2             69.5  B\n   3 │ id3             45.5  F\n   4 │ id4             88.0  A-\n   5 │ id5             98.5  A+","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"Examples of using closejoin for financial data.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> trades = Dataset(\n                [[\"20160525 13:30:00.023\",\n                  \"20160525 13:30:00.038\",\n                  \"20160525 13:30:00.048\",\n                  \"20160525 13:30:00.048\",\n                  \"20160525 13:30:00.048\"],\n                [\"MSFT\", \"MSFT\",\n                 \"GOOG\", \"GOOG\", \"AAPL\"],\n                [51.95, 51.95,\n                 720.77, 720.92, 98.00],\n                [75, 155,\n                 100, 100, 100]],\n               [\"time\", \"ticker\", \"price\", \"quantity\"]);\n\njulia> modify!(trades, 1 => byrow(x -> DateTime(x, dateformat\"yyyymmdd HH:MM:SS.s\")))\n5×4 Dataset\n Row │ time                     ticker      price     quantity\n     │ identity                 identity    identity  identity\n     │ DateTime?                String?      Float64?  Int64?\n─────┼─────────────────────────────────────────────────────────\n   1 │ 2016-05-25T13:30:00.023  MSFT           51.95        75\n   2 │ 2016-05-25T13:30:00.038  MSFT           51.95       155\n   3 │ 2016-05-25T13:30:00.048  GOOG          720.77       100\n   4 │ 2016-05-25T13:30:00.048  GOOG          720.92       100\n   5 │ 2016-05-25T13:30:00.048  AAPL           98.0        100\n\njulia> quotes = Dataset(\n              [[\"20160525 13:30:00.023\",\n                \"20160525 13:30:00.023\",\n                \"20160525 13:30:00.030\",\n                \"20160525 13:30:00.041\",\n                \"20160525 13:30:00.048\",\n                \"20160525 13:30:00.049\",\n                \"20160525 13:30:00.072\",\n                \"20160525 13:30:00.075\"],\n              [\"GOOG\", \"MSFT\", \"MSFT\", \"MSFT\",\n               \"GOOG\", \"AAPL\", \"GOOG\", \"MSFT\"],\n              [720.50, 51.95, 51.97, 51.99,\n               720.50, 97.99, 720.50, 52.01],\n              [720.93, 51.96, 51.98, 52.00,\n               720.93, 98.01, 720.88, 52.03]],\n             [\"time\", \"ticker\", \"bid\", \"ask\"]);\n\njulia> modify!(quotes, 1 => byrow(x -> DateTime(x, dateformat\"yyyymmdd HH:MM:SS.s\")))\n8×4 Dataset\n Row │ time                     ticker      bid       ask\n     │ identity                 identity    identity  identity\n     │ DateTime?                String?     Float64?  Float64?\n─────┼─────────────────────────────────────────────────────────\n   1 │ 2016-05-25T13:30:00.023  GOOG          720.5     720.93\n   2 │ 2016-05-25T13:30:00.023  MSFT           51.95     51.96\n   3 │ 2016-05-25T13:30:00.030  MSFT           51.97     51.98\n   4 │ 2016-05-25T13:30:00.041  MSFT           51.99     52.0\n   5 │ 2016-05-25T13:30:00.048  GOOG          720.5     720.93\n   6 │ 2016-05-25T13:30:00.049  AAPL           97.99     98.01\n   7 │ 2016-05-25T13:30:00.072  GOOG          720.5     720.88\n   8 │ 2016-05-25T13:30:00.075  MSFT           52.01     52.03\n\njulia> closejoin(trades, quotes, on = :time, makeunique = true)\n5×7 Dataset\n Row │ time                     ticker      price     quantity  ticker_1    bid       ask\n     │ identity                 identity    identity  identity  identity    identity  identity\n     │ DateTime?                String?     Float64?  Int64?    String?     Float64?  Float64?\n─────┼─────────────────────────────────────────────────────────────────────────────────────────\n   1 │ 2016-05-25T13:30:00.023  MSFT           51.95        75  MSFT           51.95     51.96\n   2 │ 2016-05-25T13:30:00.038  MSFT           51.95       155  MSFT           51.97     51.98\n   3 │ 2016-05-25T13:30:00.048  GOOG          720.77       100  GOOG          720.5     720.93\n   4 │ 2016-05-25T13:30:00.048  GOOG          720.92       100  GOOG          720.5     720.93\n   5 │ 2016-05-25T13:30:00.048  AAPL           98.0        100  GOOG          720.5     720.93","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"In the above example, the closejoin for each ticker can be done by passing ticker as the first variable for the on keyword, i.e. when more than one key is used for on the last one will be used for \"close match\" and the rest are used for exact match.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"When border is set to :missing (default value) for the :backward direction the value below the smallest value will be set to missing, and for the :forward direction the value above the largest value will be set to missing. And when border = :nearest the closest non-missing value will be fetched.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"Passing border = :none, sets missing for values in left data set which are out of the right data set's range.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> closejoin(trades, quotes, on = [:ticker, :time], border = :missing)\n5×6 Dataset\n Row │ time                     ticker       price     quantity  bid         ask\n     │ identity                 identity     identity  identity  identity    identity\n     │ DateTime?                String?      Float64?  Int64?    Float64?    Float64?\n─────┼─────────────────────────────────────────────────────────────────────────────────\n   1 │ 2016-05-25T13:30:00.023  MSFT           51.95        75       51.95       51.96\n   2 │ 2016-05-25T13:30:00.038  MSFT           51.95       155       51.97       51.98\n   3 │ 2016-05-25T13:30:00.048  GOOG          720.77       100      720.5       720.93\n   4 │ 2016-05-25T13:30:00.048  GOOG          720.92       100      720.5       720.93\n   5 │ 2016-05-25T13:30:00.048  AAPL           98.0        100  missing     missing\n\njulia> closejoin(trades, quotes, on = [:ticker, :time], border = :nearest)\n5×6 Dataset\n Row │ time                     ticker      price       quantity  bid       ask\n     │ identity                 identity    identity    identity  identity  identity\n     │ DateTime?                String?     Float64?    Int64?    Float64?  Float64?\n─────┼─────────────────────────────────────────────────────────────────────────────\n   1 │ 2016-05-25T13:30:00.023  MSFT           51.95        75     51.95     51.96\n   2 │ 2016-05-25T13:30:00.038  MSFT           51.95       155     51.97     51.98\n   3 │ 2016-05-25T13:30:00.048  GOOG          720.77       100    720.5     720.93\n   4 │ 2016-05-25T13:30:00.048  GOOG          720.92       100    720.5     720.93\n   5 │ 2016-05-25T13:30:00.048  AAPL           98.0        100     97.99     98.01\n","category":"page"},{"location":"man/joins/#Inequality-kind-joins","page":"Joins","title":"Inequality-kind joins","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"The innerjoin, contains, semijoin, semijoin!, antijoin, antijoin! functions can also use inequality comparisons to match observations from the left data set with the observations in the right data set. They can find all observations in the right data set that are <=(<) or >=(>) than a selected observation in the left data set. Additionally, if the user specifies two columns in the right table for a single key in the left table, they matche the observations in the left data set when they fall into the range specifies by the selected two key columns in the right data set. These conditional joins can be done within groups of observations if the user provide more than one key column for the left and the right data sets, i.e. the last key will be used for \"inequality-kind\" join and the rest will be used for the exact match.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"For these kind of joins, the key columns for both data sets which are defined for grouping observation must be passed as pair of column names (similar to normal use of other joins), however, the key column from the left data set which is going to be used for conditional joining must be also passed as a column name, and the key column(s) for conditional joining from the right data set must be passed as a Tuple of column names. For example, if the key column for the left data set is :l_key, and there are two columns in the right table called, :r_start and :r_end the following demonstrates how a user can perform different kinds of conditional joining:","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":":l_key => (:r_start, nothing), a match happens if the selected observation from the left data set is >= :r_start.\n:l_key => (nothing, :r_end), a match happens if the selected observation from the left data set is <= :r_end.\n:l_key => (:r_start, :r_end), a match happens if the selected observation from the left data set is >= :r_start and <= :r_end.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"To change inequalities to strict inequalities the strict_inequality keyword argument must be set to true for one or both sides, e.g. strict_inequality = true(both side), strict_inequality = [false, true](only one side).","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"These joins also support the method keyword argument for all key columns which are not used for inequality like join. contains and its related functions use method = :hash by default.","category":"page"},{"location":"man/joins/#Examples-3","page":"Joins","title":"Examples","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> store = Dataset([[Date(\"2019-10-01\"), Date(\"2019-10-02\"), Date(\"2019-10-05\"), Date(\"2019-10-04\"), Date(\"2019-10-03\"), Date(\"2019-10-03\")],\n               [\"A\", \"A\", \"B\", \"A\", \"B\", \"A\"]], [:date, :store])\n6×2 Dataset\n Row │ date        store    \n     │ identity    identity\n     │ Date?       String?  \n─────┼──────────────────────\n   1 │ 2019-10-01  A\n   2 │ 2019-10-02  A\n   3 │ 2019-10-05  B\n   4 │ 2019-10-04  A\n   5 │ 2019-10-03  B\n   6 │ 2019-10-03  A\n\njulia> roster = Dataset([[\"A\", \"A\", \"B\", \"A\"],\n                    [4, 1, 8, 2 ],\n                    [Date(\"2019-10-04\"), Date(\"2019-09-30\"), Date(\"2019-10-04\"), Date(\"2019-10-02\")],\n                    [Date(\"2019-10-06\"), Date(\"2019-10-04\"), Date(\"2019-10-06\"), Date(\"2019-10-04\")]],\n                    [\"store\", \"employee_ID\", \"start_date\", \"end_date\"])\n4×4 Dataset\n Row │ store     employee_ID  start_date  end_date   \n     │ identity  identity     identity    identity   \n     │ String?   Int64?       Date?       Date?      \n─────┼───────────────────────────────────────────────\n   1 │ A                   4  2019-10-04  2019-10-06\n   2 │ A                   1  2019-09-30  2019-10-04\n   3 │ B                   8  2019-10-04  2019-10-06\n   4 │ A                   2  2019-10-02  2019-10-04\n\njulia> innerjoin(store, roster, on = [:store => :store, :date => (:start_date, nothing)])\n9×4 Dataset\n Row │ date        store     employee_ID  end_date   \n     │ identity    identity  identity     identity   \n     │ Date?       String?   Int64?       Date?      \n─────┼───────────────────────────────────────────────\n   1 │ 2019-10-01  A                   1  2019-10-04\n   2 │ 2019-10-02  A                   1  2019-10-04\n   3 │ 2019-10-02  A                   2  2019-10-04\n   4 │ 2019-10-05  B                   8  2019-10-06\n   5 │ 2019-10-04  A                   1  2019-10-04\n   6 │ 2019-10-04  A                   2  2019-10-04\n   7 │ 2019-10-04  A                   4  2019-10-06\n   8 │ 2019-10-03  A                   1  2019-10-04\n   9 │ 2019-10-03  A                   2  2019-10-04\n\njulia> innerjoin(store, roster, on = [:store => :store, :date => (nothing, :end_date)])\n14×4 Dataset\n Row │ date        store     employee_ID  start_date\n     │ identity    identity  identity     identity   \n     │ Date?       String?   Int64?       Date?      \n─────┼───────────────────────────────────────────────\n   1 │ 2019-10-01  A                   1  2019-09-30\n   2 │ 2019-10-01  A                   2  2019-10-02\n   3 │ 2019-10-01  A                   4  2019-10-04\n   4 │ 2019-10-02  A                   1  2019-09-30\n   5 │ 2019-10-02  A                   2  2019-10-02\n   6 │ 2019-10-02  A                   4  2019-10-04\n   7 │ 2019-10-05  B                   8  2019-10-04\n   8 │ 2019-10-04  A                   1  2019-09-30\n   9 │ 2019-10-04  A                   2  2019-10-02\n  10 │ 2019-10-04  A                   4  2019-10-04\n  11 │ 2019-10-03  B                   8  2019-10-04\n  12 │ 2019-10-03  A                   1  2019-09-30\n  13 │ 2019-10-03  A                   2  2019-10-02\n  14 │ 2019-10-03  A                   4  2019-10-04\n\njulia> innerjoin(store, roster, on = [:store => :store, :date => (:start_date, :end_date)])\n9×3 Dataset\n Row │ date        store     employee_ID\n     │ identity    identity  identity    \n     │ Date?       String?   Int64?      \n─────┼───────────────────────────────────\n   1 │ 2019-10-01  A                   1\n   2 │ 2019-10-02  A                   1\n   3 │ 2019-10-02  A                   2\n   4 │ 2019-10-05  B                   8\n   5 │ 2019-10-04  A                   1\n   6 │ 2019-10-04  A                   2\n   7 │ 2019-10-04  A                   4\n   8 │ 2019-10-03  A                   1\n   9 │ 2019-10-03  A                   2\n\njulia> dsl = Dataset(x1 = [1,2,1,3], y = [-1.2,-3,2.1,-3.5])\n4×2 Dataset\n Row │ x1        y        \n     │ identity  identity\n     │ Int64?    Float64?\n─────┼────────────────────\n   1 │        1      -1.2\n   2 │        2      -3.0\n   3 │        1       2.1\n   4 │        3      -3.5\n\njulia> dsr = Dataset(x1 = [1,2,3], lower = [0, -3,1], upper = [3,0,2])\n3×3 Dataset\n Row │ x1        lower     upper    \n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        1         0         3\n   2 │        2        -3         0\n   3 │        3         1         2\n\njulia> contains(dsl, dsr, on = [1=>1, 2=>(2,3)], strict_inequality = true)\n4-element Vector{Bool}:\n 0\n 0\n 1\n 0","category":"page"},{"location":"man/joins/#Update-a-data-set-by-values-from-another-data-set","page":"Joins","title":"Update a data set by values from another data set","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"update! updates a data set values by using values from a transaction data set. The function uses the given keys (on = ...) to select rows for updating. By default, the missing values in transaction data set wouldn't replace the values in the main data set, however, using allowmissing = true changes this behaviour. If there are multiple rows in the main data set which match the key(s), using mode = :all causes all of them to be updated, mode = :missings causes only the ones which are missing in the main data set to be updated, and mode = fun updates the values which calling fun on them returns true. If there are multiple rows in the transaction data set which match the key, only the last one (given stable = true is passed) will be used to update the main data set.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"By default, update! updates the old values by the new values from the transaction data set, however, user may pass any function via the op keyword argument to update the values in the main data set by the result of calling op on values on both data sets. In this case, update! updates values in the main data set by op(old, new), where old is the value from the main data set and new is the value from the transaction data set.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"The update! functions replace the main data set with the updated version, however, if a copy of the updated data set is required, the update function can be used instead.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"Like other join functions, one may pass method = :hash for using hash techniques to match observations.","category":"page"},{"location":"man/joins/#Examples-4","page":"Joins","title":"Examples","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> main = Dataset(group = [\"G1\", \"G1\", \"G1\", \"G1\", \"G2\", \"G2\", \"G2\"],\n                      id    = [ 1  ,  1  ,  2  ,  2  ,  1  ,  1  ,  2  ],\n                      x1    = [1.2, 2.3,missing,  2.3, 1.3, 2.1  , 0.0 ],\n                      x2    = [ 5  ,  4  ,  4  ,  2  , 1  ,missing, 2  ])\n7×4 Dataset\n Row │ group         id        x1         x2\n     │ identity     identity  identity   identity\n     │ String?      Int64?   Float64?    Int64?\n─────┼───────────────────────────────────────────\n   1 │ G1                 1        1.2         5\n   2 │ G1                 1        2.3         4\n   3 │ G1                 2  missing           4\n   4 │ G1                 2        2.3         2\n   5 │ G2                 1        1.3         1\n   6 │ G2                 1        2.1   missing\n   7 │ G2                 2        0.0         2\n\n\njulia> transaction = Dataset(group = [\"G1\", \"G2\"], id = [2, 1],\n                        x1 = [2.5, missing], x2 = [missing, 3])\n2×4 Dataset\n Row │ group       id        x1         x2\n     │ identity    identity  identity   identity\n     │ String?       Int64?    Float64?   Int64?\n─────┼───────────────────────────────────────────\n   1 │ G1                 2        2.5   missing\n   2 │ G2                 1  missing           3\n\n\njulia> update(main, transaction, on = [:group, :id],\n               allowmissing = false, mode = :missings)\n7×4 Dataset\n Row │ group        id        x1        x2\n     │ identity     identity  identity  identity\n     │ String?       Int64?    Float64?  Int64?\n─────┼──────────────────────────────────────────\n   1 │ G1                 1       1.2         5\n   2 │ G1                 1       2.3         4\n   3 │ G1                 2       2.5         4\n   4 │ G1                 2       2.3         2\n   5 │ G2                 1       1.3         1\n   6 │ G2                 1       2.1         3\n   7 │ G2                 2       0.0         2\n\n\njulia> update(main, transaction, on = [:group, :id],\n               allowmissing = false, mode = :all)\n7×4 Dataset\n Row │ group       id        x1        x2\n     │ identity    identity  identity  identity\n     │ String?       Int64?    Float64?  Int64?\n─────┼──────────────────────────────────────────\n   1 │ G1                 1       1.2         5\n   2 │ G1                 1       2.3         4\n   3 │ G1                 2       2.5         4\n   4 │ G1                 2       2.5         2\n   5 │ G2                 1       1.3         3\n   6 │ G2                 1       2.1         3\n   7 │ G2                 2       0.0         2\n\njulia> update(main, transaction, on = [:group, :id],\n                              mode = isequal(2.3))\n7×4 Dataset\n Row │ group     id        x1         x2       \n     │ identity  identity  identity   identity\n     │ String?   Int64?    Float64?   Int64?   \n─────┼─────────────────────────────────────────\n   1 │ G1               1        1.2         5\n   2 │ G1               1        2.3         4\n   3 │ G1               2  missing           4\n   4 │ G1               2        2.5         2\n   5 │ G2               1        1.3         1\n   6 │ G2               1        2.1   missing\n   7 │ G2               2        0.0         2\n\njulia> update(main, transaction, on = [:group, :id], op = +) # add values of transaction to main, when op is set mode = :all is default\n7×4 Dataset\n Row │ group     id        x1         x2       \n     │ identity  identity  identity   identity\n     │ String?   Int64?    Float64?   Int64?   \n─────┼─────────────────────────────────────────\n   1 │ G1               1        1.2         5\n   2 │ G1               1        2.3         4\n   3 │ G1               2  missing           4\n   4 │ G1               2        4.8         2\n   5 │ G2               1        1.3         4\n   6 │ G2               1        2.1   missing\n   7 │ G2               2        0.0         2","category":"page"},{"location":"man/joins/#compare","page":"Joins","title":"compare","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"The compare function compares two data sets. When the columns which needed to be compared are specified via the cols keyword argument, compare compares the corresponding values in each row by calling eq on the actual or formatted values. By default, compare compares two values via the isequal function, however, users may pass any function via the eq keyword arguments. When the number of rows of two data sets are not matched, compare fills the output data set with missing. Users can pass key columns to perform comparing matched pairs of observations. The key columns can be passed via the on keyword argument. The compare function uses outerjoin to find the corresponding matches, this also means, the compare function can accept the arguments of outerjoin.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"To pass the mapformats keyword argument to outerjoin in compare, use the on_mapformats keyword argument, since the mapformats keyword argument in compare refers to how observations should be compared; based on actual values or formatted values.","category":"page"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"By default, the output data set contains observations id when users pass the on keyword argument. When an observation exists in only one of the passed data sets, the observation id will be missing for the other one.","category":"page"},{"location":"man/joins/#Examples-5","page":"Joins","title":"Examples","text":"","category":"section"},{"location":"man/joins/","page":"Joins","title":"Joins","text":"julia> old = Dataset(Insurance_Id=[1,2,3,5],Business_Id=[10,20,30,50],\n                     Amount=[100,200,300,missing],\n                     Account_Id=[\"x1\",\"x10\",\"x5\",\"x5\"])\n4×4 Dataset\n Row │ Insurance_Id  Business_Id  Amount    Account_Id\n     │ identity      identity     identity  identity   \n     │ Int64?        Int64?       Int64?    String?    \n─────┼─────────────────────────────────────────────────\n   1 │            1           10       100  x1\n   2 │            2           20       200  x10\n   3 │            3           30       300  x5\n   4 │            5           50   missing  x5\n\njulia> new = Dataset(Ins_Id=[1,3,2,4,3,2],\n                     B_Id=[10,40,30,40,30,20],\n                     AMT=[100,200,missing,-500,350,700],\n                     Ac_Id=[\"x1\",\"x1\",\"x10\",\"x10\",\"x7\",\"x5\"])\n6×4 Dataset\n Row │ Ins_Id    B_Id      AMT       Ac_Id    \n     │ identity  identity  identity  identity\n     │ Int64?    Int64?    Int64?    String?  \n─────┼────────────────────────────────────────\n   1 │        1        10       100  x1\n   2 │        3        40       200  x1\n   3 │        2        30   missing  x10\n   4 │        4        40      -500  x10\n   5 │        3        30       350  x7\n   6 │        2        20       700  x5\n\njulia> eq_fun(x::Number, y::Number) = abs(x - y) <= 50\neq_fun (generic function with 3 methods)\n\njulia> eq_fun(x::AbstractString, y::AbstractString) = isequal(x,y)\neq_fun (generic function with 2 methods)\n\njulia> eq_fun(x,y) = missing\neq_fun (generic function with 3 methods)\n\njulia> compare(old, new,\n                  on = [1=>1,2=>2],\n                  cols = [:Amount=>:AMT, :Account_Id=>:Ac_Id],\n                  eq = eq_fun)\n7×6 Dataset\n Row │ Insurance_Id  Business_Id  obs_id_left  obs_id_right  Amount=>AMT  Account_Id=>Ac_Id\n     │ identity      identity     identity     identity      identity     identity          \n     │ Int64?        Int64?       Int32?       Int32?        Bool?        Bool?             \n─────┼──────────────────────────────────────────────────────────────────────────────────────\n   1 │            1           10            1             1         true               true\n   2 │            2           20            2             6        false              false\n   3 │            3           30            3             5         true              false\n   4 │            5           50            4       missing      missing            missing\n   5 │            2           30      missing             3      missing            missing\n   6 │            3           40      missing             2      missing            missing\n   7 │            4           40      missing             4      missing            missing","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"<!– ```@meta CurrentModule = InMemoryDatasets","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n# Functions\n","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@index Pages = [\"functions.md\"]","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Constructing data set","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs copy similar","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Formats","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs removeformat! setformat!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Summary information","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs content ncol ndims nrow setinfo! size","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Working with column names","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs names propertynames rename rename!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Mutating and transforming data sets","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs append! combine flatten hcat insertcols! map map! modify modify! push! repeat repeat! select select! update update!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Transposing and reshaping data sets","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs transpose","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Sorting","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs sort sort! sortperm","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Joining","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs antijoin antijoin! closejoin closejoin! innerjoin leftjoin leftjoin! outerjoin semijoin semijoin!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Grouping","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs groupby groupby! ungroup!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Filtering rows","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs byrow contains deleteat! empty empty! first last mask unique unique!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Working with missing values","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs byrow completecases dropmissing dropmissing! map map!","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"\n## Statistics","category":"page"},{"location":"lib/functions/","page":"-","title":"-","text":"@docs lag lead maximum mean median minimum rescale stdze sum topk var std wmean wsum ``` –>","category":"page"},{"location":"man/formats/#Formats","page":"Formats","title":"Formats","text":"","category":"section"},{"location":"man/formats/#Introduction","page":"Formats","title":"Introduction","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"format is a named function that is assigned to a column (variable). The format of a column will be called on the individual values of the column before some operations (like show, sort,...) are done on the data set. Each column (variable) in a data set has a format property. The initial format of any column is identity, however, setformat! and removeformat! can be used to modify the format of columns in a data set. By default, the format of a column will be shown in the header when a data set is displayed.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"The format of a column doesn't change the actual values of the column, thus, the actual  values of a column will be untouched during adding or removing formats.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"The processing of format is lazy, i.e. Datasets doesn't process format unless an operation needs to access the formatted values. This also means that modifying the format of a column is instance. However, be aware that modifying a column's format changes the modified meta information (i.e. the last time that the data set has been modified) of the data set.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"Note that processing of formats are usually done in parallel, thus, it is not safe to use a function which is not parallel safe, unless threads = false is passed to the function which uses the formatted values.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"In this section, we discuss the overall aspects of format and we postpone the practical use case of format to later sections when we introduce operations which access the formatted values.","category":"page"},{"location":"man/formats/#Examples","page":"Formats","title":"Examples","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"In this example, we create a simple data set and assign iseven function as the format for :x1, by using setformat!(ds, 1 => iseven), note that we can also use the columns' names to assign format, i.e. the function can be called like setformat!(ds, :x1 => iseven). After calling setformat!, the format of the column will be set, and from this point any operation which support format will use these formatted values. One of the operations which uses formatted values is show. For instance, in the following example, the printed data set shows the formatted values.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> ds = Dataset(x1 = 1:5, x2 = [1,2,1,2,1])\n5×2 Dataset\n Row │ x1        x2\n     │ identity  identity\n     │ Int64?    Int64?\n─────┼────────────────────\n   1 │        1         1\n   2 │        2         2\n   3 │        3         1\n   4 │        4         2\n   5 │        5         1\njulia> setformat!(ds, 1 => iseven)\n5×2 Dataset\n Row │ x1      x2\n     │ iseven  identity\n     │ Int64?  Int64?\n─────┼──────────────────\n   1 │  false         1\n   2 │   true         2\n   3 │  false         1\n   4 │   true         2\n   5 │  false         1\n\njulia> ds[1,1] # note that the actual value is not changed\n1","category":"page"},{"location":"man/formats/#Manipulating-formats","page":"Formats","title":"Manipulating formats","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"There are two functions that are handy for manipulating the columns' formats, setformat! and removeformat!.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"setformat! and removeformat! are for setting and removing columns' format, respectively. The syntax of these functions are","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"setformat!(ds, arg...)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"removeformat!(ds, cols...)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"For setformat! each arg in the argument must be of the cols => fmt form, where fmt is the named function and cols is either column(s) name(s), column(s) index(s), or regular expression, thus, expressions like setformat!(ds, 1:10=>sqrt), setformat!(ds, r\"x\"=>iseven, :y=>sqrt) are valid in InMemoryDatasets. When cols refers to more than one column, fmt will be assigned to all of those columns.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"For removeformat! each cols in the argument is any column selector like column(s) name(s), column(s) index(s), or regular expression.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"Beside these two functions, there exists the getformat function to query format of a column. The syntax of getformat is","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"getformat(ds, col)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"where col is a single column identifier, i.e. column index or column's name.","category":"page"},{"location":"man/formats/#Examples-2","page":"Formats","title":"Examples","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"In the following example we assign user defined functions as the format for the first and the last column and use the month function (predefined in Julia Dates) as the format for the column :date. Note that, the actual values of columns haven't been modified, they are only shown with the formatted value. As you may observe, the formatted values can help us to scan easily the sale of each store in different month","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> sale = Dataset(store = [\"store1\", \"store1\", \"store2\",\n \t\t\t\t\"store2\", \"store3\", \"store3\", \"store3\"],\n\t\t\t\tdate = [Date(\"2020-05-01\"), Date(\"2020-06-01\"),\n\t\t\t\tDate(\"2020-05-01\"), Date(\"2020-06-01\"),\n\t\t\t\tDate(\"2020-05-01\"), Date(\"2020-06-01\"), Date(\"2020-07-01\")],\n\t\t\t\tsale = [10000, 10100, 20020, 21000, 20300, 20400, 5000])\n7×3 Dataset\n Row │ store       date        sale\n     │ identity    identity    identity\n     │ String?     Date?       Int64?\n─────┼──────────────────────────────────\n   1 │ store1      2020-05-01     10000\n   2 │ store1      2020-06-01     10100\n   3 │ store2      2020-05-01     20020\n   4 │ store2      2020-06-01     21000\n   5 │ store3      2020-05-01     20300\n   6 │ store3      2020-06-01     20400\n   7 │ store3      2020-07-01      5000\n\njulia> storeid(x) = parse(Int, replace(x, \"store\"=>\"\"))\nstoreid (generic function with 1 method)\njulia> function SALE(x)\n           if x < 10000\n               \"low\"\n           elseif x < 20000\n               \"average\"\n           elseif x < 21000\n               \"high\"\n           elseif x >= 21000\n               \"excellent\"\n           else\n               missing\n           end\n       end\nSALE (generic function with 1 method)\n\njulia> setformat!(sale, 1 => storeid, :date => month, :sale => SALE)\n7×3 Dataset\n Row │ store       date   sale\n     │ storeid     month  SALE\n     │ String?     Date?  Int64?\n─────┼──────────────────────────────\n   1 │ 1           5        average\n   2 │ 1           6        average\n   3 │ 2           5           high\n   4 │ 2           6      excellent\n   5 │ 3           5           high\n   6 │ 3           6           high\n   7 │ 3           7            low\n\njulia> getformat(sale, \"date\")\nmonth (generic function with 3 methods)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"When the formatted values are not needed for some columns, a call to removeformat! can remove them,","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> removeformat!(sale, [1,2])\n7×3 Dataset\n Row │ store       date        sale\n     │ identity    identity    SALE\n     │ String?     Date?       Int64?\n─────┼───────────────────────────────────\n   1 │ store1      2020-05-01    average\n   2 │ store1      2020-06-01    average\n   3 │ store2      2020-05-01       high\n   4 │ store2      2020-06-01  excellent\n   5 │ store3      2020-05-01       high\n   6 │ store3      2020-06-01       high\n   7 │ store3      2020-07-01        low","category":"page"},{"location":"man/formats/#Modifying-a-data-set","page":"Formats","title":"Modifying a data set","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"The following rules administrate how a column format will automatically be changed if a data set is modified:","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"As a general rule, the format of a column is preserved during different operations. For example, adding/removing a column to a data set don't change the format of the original/remaining columns.\nThe format of a column wouldn't change if only few observations are updated, modified, added, or deleted, however, if a column goes through a significant change (e.g. all values change, or the column is replaced), its format will be automatically removed.\nThe format of a column will be preserved during some operations where a new data set is created. For example, the combine function preserve the format of grouping variables. This feature will be discussed, in more details, when those operations are introduced in later sections.","category":"page"},{"location":"man/formats/#Using-Dictionary","page":"Formats","title":"Using Dictionary","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"One way to recode values of a data set is by using format which picks the formatted values from a dictionary. Since it is not possible to feed format with any extra positional argument rather than the actual values of observations, the dictionary that defines recoded values must be placed with a default value or must be set as keyword argument with a default value which refers to the actual dictionary that has been defined for this purpose. This argument should be type annotated to avoid any unnecessary allocation.","category":"page"},{"location":"man/formats/#Example","page":"Formats","title":"Example","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> ds = Dataset(rand(1:2, 10, 3), :auto)\n10×3 Dataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        1         2         1\n   2 │        1         2         2\n   3 │        1         2         2\n   4 │        2         1         1\n   5 │        1         1         2\n   6 │        1         2         2\n   7 │        2         2         1\n   8 │        2         1         2\n   9 │        2         1         1\n  10 │        1         1         1\n\njulia> dict = Dict(1=>\"yes\", 2=>\"no\")\nDict{Int64, String} with 2 entries:\n  2 => \"no\"\n  1 => \"yes\"\n\njulia> fmt1(x, dict::Dict{Int, String} = dict) = get(dict, x, missing)\nfmt1 (generic function with 2 methods)\n\njulia> setformat!(ds, 1:3 => fmt1)\n10×3 Dataset\n Row │ x1      x2      x3     \n     │ fmt1    fmt1    fmt1   \n     │ Int64?  Int64?  Int64?\n─────┼────────────────────────\n   1 │    yes      no     yes\n   2 │    yes      no      no\n   3 │    yes      no      no\n   4 │     no     yes     yes\n   5 │    yes     yes      no\n   6 │    yes      no      no\n   7 │     no      no     yes\n   8 │     no     yes      no\n   9 │     no     yes     yes\n  10 │    yes     yes     yes\n","category":"page"},{"location":"man/formats/#format-validation","page":"Formats","title":"format validation","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"InMemoryDatasets doesn't validate the supplied format until it needs to use the formatted values for an operation, in that case, if the supplied format is not a valid format, InMemoryDatasets will throw errors. Also it is important to note that InMemoryDatasets is not aware of changing the definition of a format by users, thus, changing the definition of a function which is used as a format during a workflow may have some side effects. For example if a data set is groupby! with mapformats = true option, changing the definition of the formats invalidates the sorting order of the data set, but InMemoryDatasets is unaware of this, so, it is the user responsibility to remove the invalid formats in these situations.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"In the following examples we demonstrate some scenarios which end up with an invalid format, and provide some remedies to fix the issues. Nevertheless, note that supplying an invalid format will not damage a data set and a simple call to removeformat! can be helpful to recover the original data set.","category":"page"},{"location":"man/formats/#Examples-3","page":"Formats","title":"Examples","text":"","category":"section"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"First we create a data set and define a format.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> ds = Dataset(x1 = [-1, 0, 1], x2 = [1.1, missing, 2.2], x3 = [1,2,3])\n3×3 Dataset\n Row │ x1        x2         x3\n     │ identity  identity   identity\n     │ Int64?    Float64?   Int64?\n─────┼───────────────────────────────\n   1 │       -1        1.1         1\n   2 │        0  missing           2\n   3 │        1        2.2         3\n\njulia> custom_format(x) = x[2]\ncustom_format (generic function with 1 method)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"The function supplied as format is not defined for some values: In this example, we use sqrt as :x1's format, but :x1 contains negative values and sqrt is not defined for negative integers. Running the following expression will throw bunch of errors, because after setting format InMemoryDatasets is trying to display the data set, but it cannot do that.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> setformat!(ds, 1 => sqrt)\nError showing value of type Dataset:\nERROR: DomainError with -1.0:\nsqrt will only return a complex result if called with a complex argument. Try sqrt(Complex(x)).\n[...]","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"This issue can be solve manually by defining a user defined format:","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> sqrt_fmt(x) = isless(x, 0) ? \"invalid\" : sqrt(x)\nsqrt_fmt (generic function with 1 method)\n\njulia> setformat!(ds, 1 => sqrt_fmt)\n3×3 Dataset\n Row │ x1         x2         x3\n     │ sqrt_fmt   identity   identity\n     │ Int64?     Float64?   Int64?\n─────┼────────────────────────────────\n   1 │ invalid          1.1         1\n   2 │       0.0  missing           2\n   3 │       1.0        2.2         3","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"Ignoring missing values: In this example, we use ROUND(x) = round(Int, x) as :x2 format, however, round(Int, x) doesn't know how to deal with missing values, thus, the same as the above example, InMemoryDatasets will throw errors.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> ROUND(x) = round(Int, x)\nROUND (generic function with 1 method)\n\njulia> setformat!(ds, 2 => ROUND)\nError showing value of type Dataset:\nERROR: MissingException: cannot convert a missing value to type Int64: use Union{Int64, Missing} instead\n[...]","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"To solve this issue, we can redefine ROUND as","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"ROUND(x) = ismissing(x) ? missing : round(Int, x)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"or","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"ROUND(x) = round(Union{Int, Missing}, x)","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"and every thing should be fine. Note that after updating the definition of ROUND, Datasets automatically fixes the formatted values of :x2","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> ROUND(x) = ismissing(x) ? missing : round(Int, x)\nROUND (generic function with 1 method)\n\njulia> ds\n3×3 Dataset\n Row │ x1         x2        x3\n     │ sqrt_fmt   ROUND     identity\n     │ Int64?     Float64?  Int64?\n─────┼───────────────────────────────\n   1 │ invalid           1         1\n   2 │       0.0   missing         2\n   3 │       1.0         2         3","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"The function defined as format assumes the input argument is a vector: In this example custom_format (defined earlier) is used for the third column. custom_format is defined in such a way that it assumes the input argument is a vector, but Datasets applies format to each value.","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> setformat!(ds, 3=>custom_format)\nError showing value of type Dataset:\nERROR: BoundsError\n[...]","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"To fix the issue we should redefine custom_format or simply remove the column's format:","category":"page"},{"location":"man/formats/","page":"Formats","title":"Formats","text":"julia> removeformat!(ds, 3)\n3×3 Dataset\n Row │ x1         x2        x3\n     │ sqrt_fmt   ROUND     identity\n     │ Int64?     Float64?  Int64?\n─────┼───────────────────────────────\n   1 │ invalid           1         1\n   2 │       0.0   missing         2\n   3 │       1.0         2         3","category":"page"},{"location":"man/gallery/#Gallery","page":"Gallery","title":"Gallery","text":"","category":"section"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"This gallery contains some random questions about data manipulation that we found on internet. The original questions are posted in different forums and are related to different packages. Whenever, we can remember the original source of a question we provide a link to it, otherwise, we just re-asked the question as we remember it. There is no particular theme about the questions, we just found them interesting since, a) they are not trivial, b) they can be done relatively easy in InMemoryDatasets, c) our solution is more efficient than what we found in the original source.","category":"page"},{"location":"man/gallery/#General","page":"Gallery","title":"General","text":"","category":"section"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"Tally across columns with variable condition : I am trying to tally across columns of a data frame with values that exceed a corresponding limit variable.","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> ds = Dataset([[1.66077, -1.05298, -0.499206, 2.47123, 2.45914, 1.14014],\n                     [0.75, 0.75, 0.75, 0.75, 0.75, 0.75],\n                     [0.709184, -2.53609, 0.0130659, -0.587867, 0.55786, 1.60398],\n                     [0.333, 0.333, 0.333, 0.333, 0.333, 0.333],\n                     [1.47438, 2.01485, 2.49006, 1.80345, 0.569928, 1.58403],\n                     [1, 1, 1, 1, 1, 1],\n                     [2.02678, 1.51587, 1.70535, 2.51628, 1.909, 0.794765],\n                     [1.25, 1.25, 1.25, 1.25, 1.25, 1.25]],\n                     [\"a\", \"a_lim\", \"b\", \"b_lim\", \"c\", \"c_lim\", \"d\", \"d_lim\"])\n6×8 Dataset\n Row │ a          a_lim     b           b_lim     c         c_lim     d         d_lim    \n     │ identity   identity  identity    identity  identity  identity  identity  identity\n     │ Float64?   Float64?  Float64?    Float64?  Float64?  Int64?    Float64?  Float64?\n─────┼───────────────────────────────────────────────────────────────────────────────────\n   1 │  1.66077       0.75   0.709184      0.333  1.47438          1  2.02678       1.25\n   2 │ -1.05298       0.75  -2.53609       0.333  2.01485          1  1.51587       1.25\n   3 │ -0.499206      0.75   0.0130659     0.333  2.49006          1  1.70535       1.25\n   4 │  2.47123       0.75  -0.587867      0.333  1.80345          1  2.51628       1.25\n   5 │  2.45914       0.75   0.55786       0.333  0.569928         1  1.909         1.25\n   6 │  1.14014       0.75   1.60398       0.333  1.58403          1  0.794765      1.25\n\njulia> using Chain\njulia> @chain ds begin\n         compare(_[!, r\"lim\"], _[!, Not(r\"lim\")], cols = 1:4 .=> 1:4, eq = isless)\n         byrow(count)\n       end\n6-element Vector{Int32}:\n 4\n 2\n 2\n 3\n 3\n 3","category":"page"},{"location":"man/gallery/#map!-and-map","page":"Gallery","title":"map! and map","text":"","category":"section"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"How to randomly change about 10% of data values to missing?","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> ds = Dataset(rand(10, 3), :auto)\n10×3 Dataset\n Row │ x1         x2         x3        \n     │ identity   identity   identity  \n     │ Float64?   Float64?   Float64?  \n─────┼─────────────────────────────────\n   1 │ 0.829492   0.266336   0.712512\n   2 │ 0.206569   0.252967   0.133839\n   3 │ 0.0773648  0.420897   0.363549\n   4 │ 0.404912   0.495679   0.400661\n   5 │ 0.412908   0.740628   0.785319\n   6 │ 0.624809   0.971097   0.725747\n   7 │ 0.19843    0.378382   0.0453478\n   8 │ 0.851221   0.563592   0.450065\n   9 │ 0.351243   0.0555308  0.142801\n  10 │ 0.208414   0.739952   0.926834\n\njulia> map!(ds, x->rand()<.1 ? missing : x, :)\n10×3 Dataset\n Row │ x1               x2               x3        \n     │ identity         identity         identity  \n     │ Float64?         Float64?         Float64?  \n─────┼─────────────────────────────────────────────\n   1 │       0.829492         0.266336   0.712512\n   2 │       0.206569         0.252967   0.133839\n   3 │       0.0773648        0.420897   0.363549\n   4 │       0.404912         0.495679   0.400661\n   5 │ missing                0.740628   0.785319\n   6 │       0.624809   missing          0.725747\n   7 │       0.19843          0.378382   0.0453478\n   8 │ missing                0.563592   0.450065\n   9 │       0.351243         0.0555308  0.142801\n  10 │       0.208414         0.739952   0.926834","category":"page"},{"location":"man/gallery/#Row-operations,-byrow","page":"Gallery","title":"Row operations, byrow","text":"","category":"section"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"In each row, how to replace missing values in a column by the first non-missing in previous columns. (Assuming for the first column the direction of search is reversed and all columns has the same type)","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> ds = Dataset(rand([1,2,3, missing], 10, 6), :auto)\n10×6 Dataset\n Row │ x1        x2        x3        x4        x5        x6       \n     │ identity  identity  identity  identity  identity  identity\n     │ Int64?    Int64?    Int64?    Int64?    Int64?    Int64?   \n─────┼────────────────────────────────────────────────────────────\n   1 │        1         1   missing         2   missing   missing\n   2 │        2         1         3         3         2         3\n   3 │        2         1   missing         3         3   missing\n   4 │        1   missing   missing         1         1         1\n   5 │        2         2   missing         1         3         1\n   6 │  missing   missing         2         1   missing         1\n   7 │  missing         2         3   missing         1         2\n   8 │        3         3   missing         1         1         1\n   9 │        3         1         1         3         1   missing\n  10 │  missing         1         3         1         1         3\n\njulia> byrow(ds, fill!, :, with = byrow(ds, coalesce, :), rolling = true)\n10×6 Dataset\n Row │ x1        x2        x3        x4        x5        x6       \n     │ identity  identity  identity  identity  identity  identity\n     │ Int64?    Int64?    Int64?    Int64?    Int64?    Int64?   \n─────┼────────────────────────────────────────────────────────────\n   1 │        1         1         1         2         2         2\n   2 │        2         1         3         3         2         3\n   3 │        2         1         1         3         3         3\n   4 │        1         1         1         1         1         1\n   5 │        2         2         2         1         3         1\n   6 │        2         2         2         1         1         1\n   7 │        2         2         3         3         1         2\n   8 │        3         3         3         1         1         1\n   9 │        3         1         1         3         1         1\n  10 │        1         1         3         1         1         3","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"A use-case from practice : We have a data frame that has 10,000 rows and columns, but this time we have 50% of missing values randomly scattered in it. What we want to do is to fill missing values in each row with row means of non-missing values.","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> ds = Dataset(rand([1.0, missing], 10_000, 10_000), :auto) .* (1:10_000);\n\njulia> byrow(ds, fill!, :, with = byrow(ds, mean, :));","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"How to determine whether two sets of variables have a shared value : I have a data that contains two sets of variables, and I want to compare whether the two sets have the same value. Here we provide a scalable solution where the columns for the first set  have \"1\" in their names, and the columns for the second set have \"2\" in their names.","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"since in the original post there are some specifications for checking equality of values we define a customised equality function","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> a1 = Dataset(z1 = [1,missing,3,4,5], x1 = string.(3:7), z2 = [2,missing,4,5,6], x2 = [3,5,4,7,5])\n5×4 Dataset\n Row │ z1        x1        z2        x2       \n     │ identity  identity  identity  identity\n     │ Int64?    String?   Int64?    Int64?   \n─────┼────────────────────────────────────────\n   1 │        1  3                2         3\n   2 │  missing  4          missing         5\n   3 │        3  5                4         4\n   4 │        4  6                5         7\n   5 │        5  7                6         5\n\njulia> eq(x, y) = isequal(x, y)\njulia> eq(x::String, y) = isequal(parse(Int,x), y)\njulia> eq(x, y::String) = isequal(x, parse(Int, y))\njulia> eq(x::String, y::String) = isequal(parse(Int, x), parse(Int, y))\njulia> eq(::Missing, ::Missing) = false\njulia> a1.result = reduce((x,y) -> x .|= byrow(a1, in, r\"2\", item = y, eq = eq), names(a1, r\"1\"), init = zeros(Bool, nrow(a1)))\n5-element Vector{Bool}:\n 1\n 0\n 0\n 0\n 1","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"Creating new column by selecting and matching : I want to use the option columns 1,2,3 to pull the appropriate values from length, weight, height.","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> using DLMReader, Chain\njulia> ds = filereader(IOBuffer(\"\"\"item,length,width,height,color,option_1,option_2,option_3\n                        Box 1,2,4,6,,length,width,height\n                        Tape,10,3,,clear,width,length,color\n                        Pen,,,,red,color,,\n                        \"\"\"));\n\njulia> @chain ds begin\n         filter(2:4, by = !ismissing, type = any, view = true) # filter rows with dimensions\n         modify!(Ref(2:4) .=> [byrow(select, with = 6), byrow(select, with = 7), byrow(select, with = 8)] .=> [:_t1, :_t2, :_t3],  # extract dimensions\n                 r\"_t\" => byrow(join, delim = \" × \") => :size, # create :size\n                 :size => byrow(x->\"size : \" * replace(x, r\" × $\"=>\"\")) # remove orphans \" × \" at the end\n                )\n         filter(parent(_), 5, by = !ismissing, view = true) # filter rows with colours\n         modify!(:color => byrow(x->\"color : \" * x) => :col) # create :col\n         modify!(parent(_), [:size, :col]=>byrow(x->ismissing(x[1]) ? x[2] : ismissing(x[2]) ? x[1] : x[1] * \", \" * x[2])=>:option_set) # join :size and :col\n         select!(Not([:size, :col]), Not(r\"_t\")) # remove temp columns\n      end\n3×9 Dataset\n Row │ item      length    width     height    color     option_1  option_2  option_3  option_set                   \n     │ identity  identity  identity  identity  identity  identity  identity  identity  identity                     \n     │ String?   Int64?    Int64?    Int64?    String?   String?   String?   String?   String?                      \n─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ Box 1            2         4         6  missing   length    width     height    size : 2 × 4 × 6\n   2 │ Tape            10         3   missing  clear     width     length    color     size : 3 × 10, color : clear\n   3 │ Pen        missing   missing   missing  red       color     missing   missing   color : red","category":"page"},{"location":"man/gallery/#Filtering","page":"Gallery","title":"Filtering","text":"","category":"section"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"Filtering based on conditions comparing one column to other columns : In the following example we like to filter rows where columns :x1 and :x2 are greater than :x5.","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> ds = Dataset(rand(10, 5), :auto)\n10×5 Dataset\n Row │ x1          x2         x3         x4         x5        \n     │ identity    identity   identity   identity   identity  \n     │ Float64?    Float64?   Float64?   Float64?   Float64?  \n─────┼────────────────────────────────────────────────────────\n   1 │ 0.00924202  0.780238   0.270591   0.340518   0.815554\n   2 │ 0.0653996   0.427389   0.834984   0.142269   0.632195\n   3 │ 0.930175    0.0556611  0.70946    0.424178   0.389117\n   4 │ 0.368194    0.88762    0.145652   0.0967154  0.953927\n   5 │ 0.616674    0.202607   0.0228603  0.347016   0.597645\n   6 │ 0.293204    0.570458   0.440695   0.28341    0.948588\n   7 │ 0.46431     0.519242   0.360305   0.243189   0.133591\n   8 │ 0.663426    0.756596   0.46699    0.511906   0.0340278\n   9 │ 0.681305    0.23287    0.35492    0.754141   0.134459\n  10 │ 0.0739887   0.157783   0.697812   0.421743   0.229453\n\njulia> filter(ds, 1:2, type = isless, with = :x5, rev = true)\n3×5 Dataset\n Row │ x1        x2        x3        x4        x5        \n     │ identity  identity  identity  identity  identity  \n     │ Float64?  Float64?  Float64?  Float64?  Float64?  \n─────┼───────────────────────────────────────────────────\n   1 │ 0.46431   0.519242  0.360305  0.243189  0.133591\n   2 │ 0.663426  0.756596  0.46699   0.511906  0.0340278\n   3 │ 0.681305  0.23287   0.35492   0.754141  0.134459","category":"page"},{"location":"man/gallery/#Grouping","page":"Gallery","title":"Grouping","text":"","category":"section"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"How to remove rows based on next value in a sequence? : I have a data set where it is grouped based on :id and in ascending order for :date. I want to remove a row if the row after it has the same :outcome.","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> ds = Dataset(id = [1,1,1,1,1,2,2,2,3,3,3],\n                    date = Date.([\"2019-03-05\", \"2019-03-12\", \"2019-04-10\",\n                            \"2019-04-29\", \"2019-05-10\", \"2019-03-20\",\n                            \"2019-04-22\", \"2019-05-04\", \"2019-11-01\",\n                            \"2019-11-10\", \"2019-12-12\"]),\n                    outcome = [false, false, false, true, false, false,\n                               true, false, true, true, true])\n11×3 Dataset\n Row │ id        date        outcome  \n     │ identity  identity    identity\n     │ Int64?    Date?       Bool?    \n─────┼────────────────────────────────\n   1 │        1  2019-03-05     false\n   2 │        1  2019-03-12     false\n   3 │        1  2019-04-10     false\n   4 │        1  2019-04-29      true\n   5 │        1  2019-05-10     false\n   6 │        2  2019-03-20     false\n   7 │        2  2019-04-22      true\n   8 │        2  2019-05-04     false\n   9 │        3  2019-11-01      true\n  10 │        3  2019-11-10      true\n  11 │        3  2019-12-12      true\n\njulia> combine(gatherby(ds, [1, 3], isgathered = true),\n                        (:) => last,\n                        dropgroupcols = true)\n7×3 Dataset\n Row │ last_id   last_date   last_outcome\n     │ identity  identity    identity     \n     │ Int64?    Date?       Bool?        \n─────┼────────────────────────────────────\n   1 │        1  2019-04-10         false\n   2 │        1  2019-04-29          true\n   3 │        1  2019-05-10         false\n   4 │        2  2019-03-20         false\n   5 │        2  2019-04-22          true\n   6 │        2  2019-05-04         false\n   7 │        3  2019-12-12          true\n","category":"page"},{"location":"man/gallery/#Joins","page":"Gallery","title":"Joins","text":"","category":"section"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"Counting the number of instances between dates : What I want to do is simply count the number of employees that each store has on any given date in the store data set","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> store = Dataset([Date.([\"2019-10-01\", \"2019-10-02\", \"2019-10-03\", \"2019-10-04\",\n                         \"2019-10-05\", \"2019-10-01\", \"2019-10-02\", \"2019-10-03\",\n                         \"2019-10-04\", \"2019-10-05\"]),\n                         [\"A\", \"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\", \"B\"]],\n                         [\"date\", \"store\"])\njulia> roster = Dataset([[\"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\", \"B\"],\n                         [1, 2, 3, 4, 5, 6, 7, 8],\n                         [Date(\"2019-09-30\"), Date(\"2019-10-02\"), Date(\"2019-10-03\"), Date(\"2019-10-04\"),\n                         Date(\"2019-09-30\"), Date(\"2019-10-02\"), Date(\"2019-10-03\"), Date(\"2019-10-04\")],\n                         [Date(\"2019-10-04\"), Date(\"2019-10-04\"), Date(\"2019-10-05\"), Date(\"2019-10-06\"),\n                         Date(\"2019-10-04\"), Date(\"2019-10-04\"), Date(\"2019-10-05\"), Date(\"2019-10-06\")]],\n                         [\"store\", \"employee_ID\", \"start_date\", \"end_date\"])\njulia> using Chain\njulia> @chain store begin\n          innerjoin(roster, on = [:store => :store, :date => (:start_date, :end_date)])\n          groupby([:store, :date])\n          combine(:employee_ID => length)\n       end\n10×3 Dataset\n Row │ store     date        length_employee_ID\n     │ identity  identity    identity           \n     │ String?   Date?       Int64?             \n─────┼──────────────────────────────────────────\n   1 │ A         2019-10-01                   1\n   2 │ A         2019-10-02                   2\n   3 │ A         2019-10-03                   3\n   4 │ A         2019-10-04                   4\n   5 │ A         2019-10-05                   2\n   6 │ B         2019-10-01                   1\n   7 │ B         2019-10-02                   2\n   8 │ B         2019-10-03                   3\n   9 │ B         2019-10-04                   4\n  10 │ B         2019-10-05                   2\n","category":"page"},{"location":"man/gallery/#Reshape","page":"Gallery","title":"Reshape","text":"","category":"section"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"How to transpose or pivote a table? Selecting specific columns : I need to pivot or transpose my data, keeping the Country Code, the years, and the indicators names as columns","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> ds = Dataset(\"Country_Code\"=>[\"FR\",\"FR\",\"FR\",\"USA\",\"USA\",\"USA\",\"BR\",\"BR\",\"BR\"],\n                    \"Indicator_Name\"=>[\"GPD\",\"Pop\",\"birth\",\"GPD\",\"Pop\",\"birth\",\"GPD\",\"Pop\",\"birth\"],\n                    \"2005\"=>[14,34,56, 25, 67, 68, 55, 8,99],\n                    \"2006\"=>[23, 34, 34, 43,34,34, 65, 34,45])\n9×4 Dataset\n Row │ Country_Code  Indicator_Name  2005      2006     \n     │ identity      identity        identity  identity\n     │ String?       String?         Int64?    Int64?   \n─────┼──────────────────────────────────────────────────\n   1 │ FR            GPD                   14        23\n   2 │ FR            Pop                   34        34\n   3 │ FR            birth                 56        34\n   4 │ USA           GPD                   25        43\n   5 │ USA           Pop                   67        34\n   6 │ USA           birth                 68        34\n   7 │ BR            GPD                   55        65\n   8 │ BR            Pop                    8        34\n   9 │ BR            birth                 99        45\n\njulia> transpose(gatherby(ds, 1), 3:4, id = r\"Name\")\n6×5 Dataset\n Row │ Country_Code  _variables_  GPD       Pop       birth    \n     │ identity      identity     identity  identity  identity\n     │ String?       String?      Int64?    Int64?    Int64?   \n─────┼─────────────────────────────────────────────────────────\n   1 │ FR            2005               14        34        56\n   2 │ FR            2006               23        34        34\n   3 │ USA           2005               25        67        68\n   4 │ USA           2006               43        34        34\n   5 │ BR            2005               55         8        99\n   6 │ BR            2006               65        34        45","category":"page"},{"location":"man/gallery/#for-loops","page":"Gallery","title":"for loops","text":"","category":"section"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"map select rows to a new column :  I want to use rows with names Becks, Campbell, Crows as a separate column to name the entries below them.","category":"page"},{"location":"man/gallery/","page":"Gallery","title":"Gallery","text":"julia> using Chain\njulia> ds = Dataset( [[\"Becks\", \"307NRR\", \"321NRR\", \"342NRR\", \"Campbell\", \"329NRR\", \"347NRR\", \"Crows\", \"C3001R\"],\n                     [missing, \"R\", \"R\", \"R\", missing, \"R\", \"R\", missing, \"R\"],\n                     [missing, \"CM,SG\", \"CM,SG\", \"CM,SG\", missing, \"None\", \"None\", missing, \"None\"],\n                     [missing, 3.0, 3.2, 3.4, missing, 3.2, 3.4, missing, 3.0]], :auto)\n9×4 Dataset\n Row │ x1        x2        x3        x4        \n     │ identity  identity  identity  identity  \n     │ String?   String?   String?   Float64?  \n─────┼─────────────────────────────────────────\n   1 │ Becks     missing   missing   missing   \n   2 │ 307NRR    R         CM,SG           3.0\n   3 │ 321NRR    R         CM,SG           3.2\n   4 │ 342NRR    R         CM,SG           3.4\n   5 │ Campbell  missing   missing   missing   \n   6 │ 329NRR    R         None            3.2\n   7 │ 347NRR    R         None            3.4\n   8 │ Crows     missing   missing   missing   \n   9 │ C3001R    R         None            3.0\n\njulia> function replace_with_prev(x,y)\n           res = similar(x, length(x))\n           for i in 1:length(x)\n               if !ismissing(y[i])\n                   res[i] = res[i-1]\n               else\n                   res[i] = x[i]\n               end\n           end\n           res\n       end\nf1 (generic function with 2 methods)\njulia> @chain ds begin\n         modify!((1,2)=>replace_with_prev=>:name) # find previous name\n         dropmissing!(2) # drop unwanted rows\n         select!(:name, :) # rearrange columns\n      end\n6×5 Dataset\n Row │ name      x1        x2        x3        x4       \n     │ identity  identity  identity  identity  identity\n     │ String?   String?   String?   String?   Float64?\n─────┼──────────────────────────────────────────────────\n   1 │ Becks     307NRR    R         CM,SG          3.0\n   2 │ Becks     321NRR    R         CM,SG          3.2\n   3 │ Becks     342NRR    R         CM,SG          3.4\n   4 │ Campbell  329NRR    R         None           3.2\n   5 │ Campbell  347NRR    R         None           3.4\n   6 │ Crows     C3001R    R         None           3.0","category":"page"},{"location":"man/map/#Function-map/map!","page":"Call functions on each observation","title":"Function map/map!","text":"","category":"section"},{"location":"man/map/#Introduction","page":"Call functions on each observation","title":"Introduction","text":"","category":"section"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"There are multiple ways to call a function on individual values (observations) of a column. In this section we discuss two of them: map! and map. These two functions are high-performance and customised version of map! and map in Julia Base.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"map! and map call functions on the actual values, i.e. if the column is formatted the functions are called on the values which may be different from what you see when show a data set.","category":"page"},{"location":"man/map/#map!","page":"Call functions on each observation","title":"map!","text":"","category":"section"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"The InMemoryDatasets' map! function modifies a data set in-place by calling a function on individual values of a column. The syntax for the function is","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"map!(ds, fun, cols; threads = true)","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"where ds is a data set, and cols can be a single column or multiple columns selector. When fun is a single function, map! call that function on all values of cols. Since map! is modifying the data set ds in-place, it will skip columns in cols where fun changes the type of columns, and print a warning on the screen.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"The threads = true keyword argument causes map! to exploit all cores available to Julia for doing the calculations. This is particularly useful when the fun function is expensive to calculate.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"When fun is a vector of functions and cols refers to multiple columns, map! calls each element of fun to the values of the corresponding column in cols. this means that it is possible to call different functions on different columns of a data set, however, the length of fun and the number of selected columns must be the same.","category":"page"},{"location":"man/map/#Examples","page":"Call functions on each observation","title":"Examples","text":"","category":"section"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"In the following data set we like to replace every missing in :x2 and :x3 with value 0. Thus, we use map! and a suitable function to do this:","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"julia> ds = Dataset(x1 = 1:5, x2 = [-2, -1, missing, 1, 2],\n                    x3 = [0.0, 0.1, 0.2, missing, 0.4])\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1        -2       0.0\n   2 │        2        -1       0.1\n   3 │        3   missing       0.2\n   4 │        4         1   missing\n   5 │        5         2       0.4\n\njulia> map!(ds, x -> ismissing(x) ? 0 : x, 2:3)\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1        -2       0.0\n   2 │        2        -1       0.1\n   3 │        3         0       0.2\n   4 │        4         1       0.0\n   5 │        5         2       0.4","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"Now let's call sqrt on all values. Note that sqrt of an integer is a float and sqrt of negative integer is not valid in Julia. So map! only applies the provided function on the last column and skips the first two columns.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"julia> map!(ds, sqrt, :)\n┌ Warning: cannot map `f` on ds[!, :x1] in-place, the selected column is Union{Missing, Int64} and the result of calculation is Union{Missing, Float64}\n└ @ InMemoryDatasets ...\n┌ Warning: cannot map `f` on ds[!, :x2] in-place, the selected column is Union{Missing, Int64} and the result of calculation is Union{Missing, Float64}\n└ @ InMemoryDatasets ...\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1        -2  0.0\n   2 │        2        -1  0.316228\n   3 │        3         0  0.447214\n   4 │        4         1  0.0\n   5 │        5         2  0.632456","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"As another example let's look at a data set where a column already has a format.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"julia> ds = Dataset(x1 = 1:5, x2 = [1,2,1,2,1])\njulia> setformat!(ds, 1=>isodd)\n5×2 Dataset\n Row │ x1      x2\n     │ isodd   identity\n     │ Int64?  Int64?\n─────┼──────────────────\n   1 │   true         1\n   2 │  false         2\n   3 │   true         1\n   4 │  false         2\n   5 │   true         1\n\njulia> map!(ds, x->div(x,2), 1:2)\n5×2 Dataset\n Row │ x1      x2\n     │ isodd   identity\n     │ Int64?  Int64?\n─────┼──────────────────\n   1 │  false         0\n   2 │   true         1\n   3 │   true         0\n   4 │  false         1\n   5 │  false         0","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"Note that the format of :x1 is preserved and the function call changed the actual values. Thus, Datasets applies the format of :x1 to new values.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"The following example shows how different functions can be used for different columns.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"julia> ds = Dataset(x1 = 1:5, x2 = [-2, -1, missing, 1, 2],\n                    x3 = [0.0, 0.1, 0.2, missing, 0.4])\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1        -2       0.0\n   2 │        2        -1       0.1\n   3 │        3   missing       0.2\n   4 │        4         1   missing\n   5 │        5         2       0.4\n\njulia> fun_vec = [x -> div(x, 2),\n                  x -> ismissing(x) ? 0 : x,\n                  sqrt]\n3-element Vector{Function}:\n #5 (generic function with 1 method)\n #6 (generic function with 1 method)\n sqrt (generic function with 19 methods)\n\njulia> map!(ds, fun_vec, 1:3)\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼────────────────────────────────────\n   1 │        0        -2        0.0\n   2 │        1        -1        0.316228\n   3 │        1         0        0.447214\n   4 │        2         1  missing\n   5 │        2         2        0.632456","category":"page"},{"location":"man/map/#map","page":"Call functions on each observation","title":"map","text":"","category":"section"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"The map function also calls a function (or a vector of functions) on single or muliple columns of a data set. However, it differs from map! that we discussed earlier in three main areas,","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"it doesn't do in-place operation and returns a copy of the data set,\nunlike map!, it can change the type of columns, and\nit doesn't preserve the formats of the columns that are going to be modified.","category":"page"},{"location":"man/map/#Examples-2","page":"Call functions on each observation","title":"Examples","text":"","category":"section"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"In the following example we call x -> x/2 on all columns. However, note that map automatically changes the data type of the first two columns, and more importantly it doesn't modify the original data set:","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"julia> ds = Dataset(x1 = 1:5, x2 = [-2, -1, missing, 1, 2],\n                    x3 = [0.0, 0.1, 0.2, missing, 0.4])\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1        -2       0.0\n   2 │        2        -1       0.1\n   3 │        3   missing       0.2\n   4 │        4         1   missing\n   5 │        5         2       0.4\njulia> map(ds, x -> x/2, r\"x\")\n5×3 Dataset\n Row │ x1        x2         x3\n     │ identity  identity   identity\n     │ Float64?  Float64?   Float64?\n─────┼─────────────────────────────────\n   1 │      0.5       -1.0        0.0\n   2 │      1.0       -0.5        0.05\n   3 │      1.5  missing          0.1\n   4 │      2.0        0.5  missing\n   5 │      2.5        1.0        0.2\n\njulia> ds # map doesn't modify the original data set\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼───────────────────────────────\n   1 │        1        -2        0.0\n   2 │        2        -1        0.1\n   3 │        3   missing        0.2\n   4 │        4         1  missing\n   5 │        5         2        0.4","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"In the following example, we map some functions on columns of a data set which one of the columns has a format.","category":"page"},{"location":"man/map/","page":"Call functions on each observation","title":"Call functions on each observation","text":"julia> ds = Dataset(x1 = 1:5, x2 = [1,2,1,2,1])\njulia> setformat!(ds, 1=>isodd)\n5×2 Dataset\n Row │ x1      x2\n     │ isodd   identity\n     │ Int64?  Int64?\n─────┼──────────────────\n   1 │   true         1\n   2 │  false         2\n   3 │   true         1\n   4 │  false         2\n   5 │   true         1\n\njulia> map(ds, [x -> div(x,2), x -> x/2], :)\n5×2 Dataset\n Row │ x1        x2\n     │ identity  identity\n     │ Int64?    Float64?\n─────┼────────────────────\n   1 │        0       0.5\n   2 │        1       1.0\n   3 │        1       0.5\n   4 │        2       1.0\n   5 │        2       0.5","category":"page"},{"location":"man/transpose/#Reshape-data-sets","page":"Transpose data","title":"Reshape data sets","text":"","category":"section"},{"location":"man/transpose/#Introduction","page":"Transpose data","title":"Introduction","text":"","category":"section"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"In InMemoryDatasets the reshaping of a data set is done by the transpose function. In the simplest case, you can think about a data set as a matrix, and transpose simply flips it over its diagonal; that is, transpose switches the row and column indices of it. The key feature that makes transpose  versatile and powerful is its ability to do the simple transposing within each group of observations created by groupby!, groupby or gatherby. Basically, the two popular functions for reshaping data, stack and unstack, are special cases of transpose; The stack function transposes each row of a data set, and the unstack function transposes one column of a data set for each group of observations.","category":"page"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"By default, the transpose function uses parallel algorithms to perform the transposing, however, this can be switched to single threaded process by setting the threads keyword argument to false.","category":"page"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"In this section we give the details of reshaping a data set using the transpose function.","category":"page"},{"location":"man/transpose/#Simple-case","page":"Transpose data","title":"Simple case","text":"","category":"section"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"Transpose means switching the row and column indices of a matrix, and in InMemoryDatasets when we select a set of columns, we practically have a matrix shape array of data, thus, its transposition means switching the row and column indices of it. Thus, in the simplest form, the syntax of the transpose function is transpose(ds, cols), where ds is the input data set and cols is any kind of column selector which specifies the selected columns for transposing. Since each column of a data set has also a name, transpose creates a new column in the output data set which shows those names from the input data set. By default, the column name for this new column is set to _variables_, and it can be change to any name by using the keyword argument variable_name. The transpose function has a keyword argument renamerowid, which can accept a user defined function to apply on the values of this new added column. Additionally, the keyword argument can be set to nothing if the new column is not needed in the output data set.","category":"page"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"The rows of a data set haven't got names, thus, InMemoryDatasets uses automatic name generation to produce the names for the transposed columns of the output data set. User can supply a custom function for generating the names of the transposed columns by using the keyword argument renamecolid, which by default is set as i -> \"_c\" * string(i) where i is the sequence of columns. User can also set the id keyword argument to a column in the input data set when the values of the column can be used as the names for the transposed columns in the output data set. By default, the id keyword argument uses the formatted values as the names of the transposed columns, however, this can be turned off by using the mapformats = false keyword argument.","category":"page"},{"location":"man/transpose/#Examples","page":"Transpose data","title":"Examples","text":"","category":"section"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"julia> ds = Dataset(x1 = [1,2,3,4], x2 = [1,4,9,16])\n4×2 Dataset\n Row │ x1        x2       \n     │ identity  identity\n     │ Int64?    Int64?   \n─────┼────────────────────\n   1 │        1         1\n   2 │        2         4\n   3 │        3         9\n   4 │        4        16\n\njulia> transpose(ds, 1:2)\n2×5 Dataset\n Row │ _variables_  _c1       _c2       _c3       _c4      \n     │ identity     identity  identity  identity  identity\n     │ String?      Int64?    Int64?    Int64?    Int64?   \n─────┼─────────────────────────────────────────────────────\n   1 │ x1                  1         2         3         4\n   2 │ x2                  1         4         9        16\n\njulia> transpose(Matrix(ds)) # transpose of a data set, in the simplest case, is similar to matrix transposition\n2×4 transpose(::Matrix{Union{Missing, Int64}}) with eltype Union{Missing, Int64}:\n 1  2  3   4\n 1  4  9  16\n\njulia> insertcols!(ds, 1, :id => [\"r1\", \"r2\", \"r3\" , \"r4\"])\n4×3 Dataset\n Row │ id        x1        x2       \n     │ identity  identity  identity\n     │ String?   Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │ r1               1         1\n   2 │ r2               2         4\n   3 │ r3               3         9\n   4 │ r4               4        16\n\njulia> transpose(ds, [:x1, :x2], id = :id)\n2×5 Dataset\n Row │ _variables_  r1        r2        r3        r4       \n     │ identity     identity  identity  identity  identity\n     │ String?      Int64?    Int64?    Int64?    Int64?   \n─────┼─────────────────────────────────────────────────────\n   1 │ x1                  1         2         3         4\n   2 │ x2                  1         4         9        16\n\njulia> transpose(ds, [:x1, :x2], renamecolid = x -> \"_COLUMN_\" * string(x))\n2×5 Dataset\n Row │ _variables_  _COLUMN_1  _COLUMN_2  _COLUMN_3  _COLUMN_4\n     │ identity     identity   identity   identity   identity  \n     │ String?      Int64?     Int64?     Int64?     Int64?    \n─────┼─────────────────────────────────────────────────────────\n   1 │ x1                   1          2          3          4\n   2 │ x2                   1          4          9         16\n\njulia> transpose(ds, [:x1, :x2], renamerowid = x -> replace(x, \"x\"=>\"\"))\n2×5 Dataset\n Row │ _variables_  _c1       _c2       _c3       _c4      \n     │ identity     identity  identity  identity  identity\n     │ String?      Int64?    Int64?    Int64?    Int64?   \n─────┼─────────────────────────────────────────────────────\n   1 │ 1                   1         2         3         4\n   2 │ 2                   1         4         9        16\n\njulia> transpose(ds, [:x1, :x2], id = :id, variable_name = nothing)\n2×4 Dataset\n Row │ r1        r2        r3        r4       \n     │ identity  identity  identity  identity\n     │ Int64?    Int64?    Int64?    Int64?   \n─────┼────────────────────────────────────────\n   1 │        1         2         3         4\n   2 │        1         4         9        16\n\njulia> ds2 = Dataset(a=[\"x\", \"y\"], b=[1, \"two\"], c=[3, 4], d=[true, false])\n2×4 Dataset\n Row │ a         b         c         d        \n     │ identity  identity  identity  identity\n     │ String?   Any       Int64?    Bool?    \n─────┼────────────────────────────────────────\n   1 │ x         1                3      true\n   2 │ y         two              4     false\n\njulia> transpose(ds2, Between(:b, :d), id = :a) # promoting the values\n3×3 Dataset\n Row │ _variables_  x         y        \n     │ identity     identity  identity\n     │ String?      Any       Any      \n─────┼─────────────────────────────────\n   1 │ b            1         two\n   2 │ c            3         4\n   3 │ d            true      false","category":"page"},{"location":"man/transpose/#transpose-of-grouped-data-sets","page":"Transpose data","title":"transpose of grouped data sets","text":"","category":"section"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"When the first argument of the transpose function is a grouped data set - created by groupby!, groupby, or gatherby - transpose does the simple transposing within each group of observations. Thus, the transposition of a grouped data set can be viewed as transposing the matrix shape data values which are created for each group of observations. Since the size of transposed columns within each group can be different, transpose pads them with missing values to overcome this problem. The missing padding can be replaced by any other values which passed to default keyword argument of the function.","category":"page"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"julia> ds = Dataset(group = repeat(1:3, inner = 2),\n                                    b = repeat(1:2, inner = 3),\n                                    c = repeat(1:1, inner = 6),\n                                    d = repeat(1:6, inner = 1),\n                                    e = string.('a':'f'))\n6×5 Dataset\n Row │ group     b         c         d         e        \n     │ identity  identity  identity  identity  identity\n     │ Int64?    Int64?    Int64?    Int64?    String?  \n─────┼──────────────────────────────────────────────────\n   1 │        1         1         1         1  a\n   2 │        1         1         1         2  b\n   3 │        2         1         1         3  c\n   4 │        2         2         1         4  d\n   5 │        3         2         1         5  e\n   6 │        3         2         1         6  f\n\njulia> transpose(groupby(ds, :group), 2:4)\n9×4 Dataset\n Row │ group     _variables_  _c1       _c2      \n     │ identity  identity     identity  identity\n     │ Int64?    String?      Int64?    Int64?   \n─────┼───────────────────────────────────────────\n   1 │        1  b                   1         1\n   2 │        1  c                   1         1\n   3 │        1  d                   1         2\n   4 │        2  b                   1         2\n   5 │        2  c                   1         1\n   6 │        2  d                   3         4\n   7 │        3  b                   2         2\n   8 │        3  c                   1         1\n   9 │        3  d                   5         6\n\njulia> transpose(groupby(ds, :group), 2:4, id = :e)\n9×8 Dataset\n Row │ group     _variables_  a         b         c         d         e         f        \n     │ identity  identity     identity  identity  identity  identity  identity  identity\n     │ Int64?    String?      Int64?    Int64?    Int64?    Int64?    Int64?    Int64?   \n─────┼───────────────────────────────────────────────────────────────────────────────────\n   1 │        1  b                   1         1   missing   missing   missing   missing\n   2 │        1  c                   1         1   missing   missing   missing   missing\n   3 │        1  d                   1         2   missing   missing   missing   missing\n   4 │        2  b             missing   missing         1         2   missing   missing\n   5 │        2  c             missing   missing         1         1   missing   missing\n   6 │        2  d             missing   missing         3         4   missing   missing\n   7 │        3  b             missing   missing   missing   missing         2         2\n   8 │        3  c             missing   missing   missing   missing         1         1\n   9 │        3  d             missing   missing   missing   missing         5         6\n\njulia> transpose(groupby(ds, :group), 2:4, id = :e, default = 99999)\n9×8 Dataset\n Row │ group     _variables_  a         b         c         d         e         f        \n     │ identity  identity     identity  identity  identity  identity  identity  identity\n     │ Int64?    String?      Int64?    Int64?    Int64?    Int64?    Int64?    Int64?   \n─────┼───────────────────────────────────────────────────────────────────────────────────\n   1 │        1  b                   1         1     99999     99999     99999     99999\n   2 │        1  c                   1         1     99999     99999     99999     99999\n   3 │        1  d                   1         2     99999     99999     99999     99999\n   4 │        2  b               99999     99999         1         2     99999     99999\n   5 │        2  c               99999     99999         1         1     99999     99999\n   6 │        2  d               99999     99999         3         4     99999     99999\n   7 │        3  b               99999     99999     99999     99999         2         2\n   8 │        3  c               99999     99999     99999     99999         1         1\n   9 │        3  d               99999     99999     99999     99999         5         6\n\njulia> pop = Dataset(country = [\"c1\",\"c1\",\"c2\",\"c2\",\"c3\",\"c3\"],\n                               sex = [1, 2, 1, 2, 1, 2],\n                               pop_2000 = [100, 120, 150, 155, 170, 190],\n                               pop_2010 = [110, 120, 155, 160, 178, 200],\n                               pop_2020 = [115, 130, 161, 165, 180, 203])\n6×5 Dataset\n Row │ country   sex       pop_2000  pop_2010  pop_2020\n     │ identity  identity  identity  identity  identity\n     │ String?   Int64?    Int64?    Int64?    Int64?   \n─────┼──────────────────────────────────────────────────\n   1 │ c1               1       100       110       115\n   2 │ c1               2       120       120       130\n   3 │ c2               1       150       155       161\n   4 │ c2               2       155       160       165\n   5 │ c3               1       170       178       180\n   6 │ c3               2       190       200       203\n\njulia> gender(x) = x == 1 ? \"Male\" : \"Female\"\ngender (generic function with 1 method)\n\njulia> setformat!(pop, 2 => gender)\n6×5 Dataset\n Row │ country   sex     pop_2000  pop_2010  pop_2020\n     │ identity  gender  identity  identity  identity\n     │ String?   Int64?  Int64?    Int64?    Int64?   \n─────┼────────────────────────────────────────────────\n   1 │ c1          Male       100       110       115\n   2 │ c1        Female       120       120       130\n   3 │ c2          Male       150       155       161\n   4 │ c2        Female       155       160       165\n   5 │ c3          Male       170       178       180\n   6 │ c3        Female       190       200       203\n\njulia> transpose(gatherby(pop, 1, isgathered = true), r\"pop\", id = :sex)\n9×4 Dataset\n Row │ country   _variables_  Male      Female   \n     │ identity  identity     identity  identity\n     │ String?   String?      Int64?    Int64?   \n─────┼───────────────────────────────────────────\n   1 │ c1        pop_2000          100       120\n   2 │ c1        pop_2010          110       120\n   3 │ c1        pop_2020          115       130\n   4 │ c2        pop_2000          150       155\n   5 │ c2        pop_2010          155       160\n   6 │ c2        pop_2020          161       165\n   7 │ c3        pop_2000          170       190\n   8 │ c3        pop_2010          178       200\n   9 │ c3        pop_2020          180       203\njulia> ds = Dataset(region = repeat([\"North\",\"North\",\"South\",\"South\"],2),\n                    fuel_type = repeat([\"gas\",\"coal\"],4),\n                    load = rand(8),\n                    time = [1,1,1,1,2,2,2,2],\n                    )\n8×4 Dataset\n Row │ region    fuel_type  load       time     \n     │ identity  identity   identity   identity\n     │ String?   String?    Float64?   Int64?   \n─────┼──────────────────────────────────────────\n   1 │ North     gas        0.914918          1\n   2 │ North     coal       0.158792          1\n   3 │ South     gas        0.415604          1\n   4 │ South     coal       0.0702206         1\n   5 │ North     gas        0.419423          2\n   6 │ North     coal       0.765637          2\n   7 │ South     gas        0.222119          2\n   8 │ South     coal       0.723559          2\n\njulia> transpose(groupby(ds, :time), :load, id = 1:2)\n2×6 Dataset\n Row │ time      _variables_  (\"North\", \"gas\")  (\"North\", \"coal\")  (\"South\", \"gas\")  (\"South\", \"coal\")\n     │ identity  identity     identity          identity           identity          identity          \n     │ Int64?    String?      Float64?          Float64?           Float64?          Float64?          \n─────┼─────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │        1  load                 0.778866          0.0256356          0.729273           0.786919\n   2 │        2  load                 0.676968          0.366241           0.577498           0.294181\n\njulia> ds = Dataset([[1, 2, 3], [1.1, 2.0, 3.3],[1.1, 2.1, 3.0],[1.1, 2.0, 3.2]]\n                           ,[:person, Symbol(\"11/2020\"), Symbol(\"12/2020\"), Symbol(\"1/2021\")])\n3×4 Dataset\n Row │ person    11/2020   12/2020   1/2021   \n     │ identity  identity  identity  identity\n     │ Float64?  Float64?  Float64?  Float64?\n─────┼────────────────────────────────────────\n   1 │      1.0       1.1       1.1       1.1\n   2 │      2.0       2.0       2.1       2.0\n   3 │      3.0       3.3       3.0       3.2\n\njulia> transpose(gatherby(ds, :person), Not(:person),\n                variable_name = \"Date\",\n                renamerowid = x -> Date(x, dateformat\"m/y\"),\n                renamecolid = x -> \"measurement\")\n9×3 Dataset\n Row │ person    Date        measurement\n     │ identity  identity    identity    \n     │ Float64?  Date?       Float64?    \n─────┼───────────────────────────────────\n   1 │      1.0  2020-11-01          1.1\n   2 │      1.0  2020-12-01          1.1\n   3 │      1.0  2021-01-01          1.1\n   4 │      2.0  2020-11-01          2.0\n   5 │      2.0  2020-12-01          2.1\n   6 │      2.0  2021-01-01          2.0\n   7 │      3.0  2020-11-01          3.3\n   8 │      3.0  2020-12-01          3.0\n   9 │      3.0  2021-01-01          3.2\n\njulia> ds = Dataset(A_2018=1:4, A_2019=5:8, B_2017=9:12,\n                               B_2018=9:12, B_2019 = [missing,13,14,15],\n                                ID = [1,2,3,4])\n4×6 Dataset\n Row │ A_2018    A_2019    B_2017    B_2018    B_2019    ID       \n     │ identity  identity  identity  identity  identity  identity\n     │ Int64?    Int64?    Int64?    Int64?    Int64?    Int64?   \n─────┼────────────────────────────────────────────────────────────\n   1 │        1         5         9         9   missing         1\n   2 │        2         6        10        10        13         2\n   3 │        3         7        11        11        14         3\n   4 │        4         8        12        12        15         4\n\njulia> f(x) =  replace(x, r\"[A_B]\"=>\"\")\nf (generic function with 1 method)\n\njulia> ; # later we provide a simpler solution for this example\n\njulia> dsA = transpose(groupby(ds, :ID), r\"A\", renamerowid = f, variable_name = \"Year\", renamecolid = x->\"A\");\n\njulia> dsB = transpose(groupby(ds, :ID), r\"B\", renamerowid = f, variable_name = \"Year\", renamecolid = x->\"B\");\n\njulia> outerjoin(dsA, dsB, on = [:ID, :Year])\n12×4 Dataset\n Row │ ID        Year      A         B        \n     │ identity  identity  identity  identity\n     │ Int64?    String?   Int64?    Int64?   \n─────┼────────────────────────────────────────\n   1 │        1  2018             1         9\n   2 │        1  2019             5   missing\n   3 │        2  2018             2        10\n   4 │        2  2019             6        13\n   5 │        3  2018             3        11\n   6 │        3  2019             7        14\n   7 │        4  2018             4        12\n   8 │        4  2019             8        15\n   9 │        1  2017       missing         9\n  10 │        2  2017       missing        10\n  11 │        3  2017       missing        11\n  12 │        4  2017       missing        12","category":"page"},{"location":"man/transpose/#Advanced-options","page":"Transpose data","title":"Advanced options","text":"","category":"section"},{"location":"man/transpose/#reanemcolid-with-two-arguments","page":"Transpose data","title":"reanemcolid with two arguments","text":"","category":"section"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"The renamecolid function can also get access to the variable names from the input data set as the second argument. This can be used to generate even more customised column names for the output data set.","category":"page"},{"location":"man/transpose/#Passing-Tuple-of-column-selectors","page":"Transpose data","title":"Passing Tuple of column selectors","text":"","category":"section"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"The column selector of the transpose function can be also a Tuple of column selectors. In this case, InMemoryDatasets does the transposition for each element of the tuple and then horizontally concatenates the output data sets to create a single data set. This provides extra flexibility to the user for reshaping a data set. By default, the variable_name is set to nothing, when Tuple of column selectors is passed as the argument, however, we can supply different names for each element of the Tuple.","category":"page"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"Since the column names for the output data set can be the same for all elements of the tuple, transpose automatically modifies them to make them unique. Nevertheless, by passing renamecolid, we can customise the column names.","category":"page"},{"location":"man/transpose/#Examples-2","page":"Transpose data","title":"Examples","text":"","category":"section"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"julia> ds = Dataset([[1, 1, 1, 2, 2, 2],\n                        [\"foo\", \"bar\", \"monty\", \"foo\", \"bar\", \"monty\"],\n                        [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n                        [1, 2, 3, 4, 5, 6]], [:g, :key, :foo, :bar])\n6×4 Dataset\n Row │ g         key       foo       bar      \n     │ identity  identity  identity  identity\n     │ Int64?    String?   String?   Int64?   \n─────┼────────────────────────────────────────\n   1 │        1  foo       a                1\n   2 │        1  bar       b                2\n   3 │        1  monty     c                3\n   4 │        2  foo       d                4\n   5 │        2  bar       e                5\n   6 │        2  monty     f                6\n\njulia> transpose(groupby(ds, :g), (:foo, :bar), id = :key)\n2×7 Dataset\n Row │ g         foo       bar       monty     foo_1     bar_1     monty_1  \n     │ identity  identity  identity  identity  identity  identity  identity\n     │ Int64?    String?   String?   String?   Int64?    Int64?    Int64?   \n─────┼──────────────────────────────────────────────────────────────────────\n   1 │        1  a         b         c                1         2         3\n   2 │        2  d         e         f                4         5         6\n\njulia> transpose(groupby(ds, :g), (:foo, :bar), id = :key,\n                  renamecolid = (x,y) -> string(x,\"_\",y[1]))\n2×7 Dataset\n Row │ g         foo_foo   bar_foo   monty_foo  foo_bar   bar_bar   monty_bar\n     │ identity  identity  identity  identity   identity  identity  identity  \n     │ Int64?    String?   String?   String?    Int64?    Int64?    Int64?    \n─────┼────────────────────────────────────────────────────────────────────────\n   1 │        1  a         b         c                 1         2          3\n   2 │        2  d         e         f                 4         5          6\n\njulia> ds = Dataset(paddockId= [0, 0, 1, 1, 2, 2],\n                               color= [\"red\", \"blue\", \"red\", \"blue\", \"red\", \"blue\"],\n                               count= [3, 4, 3, 4, 3, 4],\n                               weight= [0.2, 0.3, 0.2, 0.3, 0.2, 0.2])\n6×4 Dataset\n Row │ paddockId  color     count     weight   \n     │ identity   identity  identity  identity\n     │ Int64?     String?   Int64?    Float64?\n─────┼─────────────────────────────────────────\n   1 │         0  red              3       0.2\n   2 │         0  blue             4       0.3\n   3 │         1  red              3       0.2\n   4 │         1  blue             4       0.3\n   5 │         2  red              3       0.2\n   6 │         2  blue             4       0.2\n\njulia> transpose(groupby(ds, 1), (:count, :weight),\n                         id = :color,\n                         renamecolid = (x,y)->string(x,\"/\",y[1]),\n                         )\n3×5 Dataset\n Row │ paddockId  red/count  blue/count  red/weight  blue/weight\n     │ identity   identity   identity    identity    identity    \n     │ Int64?     Int64?     Int64?      Float64?    Float64?    \n─────┼───────────────────────────────────────────────────────────\n   1 │         0          3           4         0.2          0.3\n   2 │         1          3           4         0.2          0.3\n   3 │         2          3           4         0.2          0.2\n\njulia> ds = Dataset(A_2018=1:4, A_2019=5:8, B_2017=9:12,\n                               B_2018=9:12, B_2019 = [missing,13,14,15],\n                                ID = [1,2,3,4])\n4×6 Dataset\n Row │ A_2018    A_2019    B_2017    B_2018    B_2019    ID       \n     │ identity  identity  identity  identity  identity  identity\n     │ Int64?    Int64?    Int64?    Int64?    Int64?    Int64?   \n─────┼────────────────────────────────────────────────────────────\n   1 │        1         5         9         9   missing         1\n   2 │        2         6        10        10        13         2\n   3 │        3         7        11        11        14         3\n   4 │        4         8        12        12        15         4\n\njulia> f(x) =  replace(x, r\"[A_B]\"=>\"\")\nf (generic function with 1 method)\n\njulia> transpose(gatherby(ds, :ID), ([4,5,3], [1,2]),\n                  variable_name = [:year, nothing],\n                  renamerowid = f,\n                  renamecolid = (x,y)->y[1][1:1])\n12×4 Dataset\n Row │ ID        year      B         A        \n     │ identity  identity  identity  identity\n     │ Int64?    String?   Int64?    Int64?   \n─────┼────────────────────────────────────────\n   1 │        1  2018             9         1\n   2 │        1  2019       missing         5\n   3 │        1  2017             9   missing\n   4 │        2  2018            10         2\n   5 │        2  2019            13         6\n   6 │        2  2017            10   missing\n   7 │        3  2018            11         3\n   8 │        3  2019            14         7\n   9 │        3  2017            11   missing\n  10 │        4  2018            12         4\n  11 │        4  2019            15         8\n  12 │        4  2017            12   missing\n\njulia> ds = Dataset(rand(1:10, 2, 6), :auto)\n2×6 Dataset\n Row │ x1        x2        x3        x4        x5        x6       \n     │ identity  identity  identity  identity  identity  identity\n     │ Int64?    Int64?    Int64?    Int64?    Int64?    Int64?   \n─────┼────────────────────────────────────────────────────────────\n   1 │       10         6         8        10        10         3\n   2 │        9         7         9         4         2        10\n\njulia> transpose(ds, ntuple(i->[i, i+3], 3), renamecolid = (x,y)->string(y[x]))\n2×6 Dataset\n Row │ x1        x4        x2        x5        x3        x6       \n     │ identity  identity  identity  identity  identity  identity\n     │ Int64?    Int64?    Int64?    Int64?    Int64?    Int64?   \n─────┼────────────────────────────────────────────────────────────\n   1 │       10         9         6         7         8         9\n   2 │       10         4        10         2         3        10","category":"page"},{"location":"man/transpose/#Spreadsheet-style-pivot-table","page":"Transpose data","title":"Spreadsheet-style pivot table","text":"","category":"section"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"To create a spreadsheet-style pivot tables in InMemoryDatasets, one can use the combination of the combine and transpose functions. To demonstrate this, we re-produce the documentation's examples of the pandas's pivot_table function (ver: 1.3.4).","category":"page"},{"location":"man/transpose/","page":"Transpose data","title":"Transpose data","text":"julia> ds = Dataset(A = [\"foo\", \"foo\", \"foo\", \"foo\", \"foo\",\n                       \"bar\", \"bar\", \"bar\", \"bar\"],\n                       B = [\"one\", \"one\", \"one\", \"two\", \"two\",\n                       \"one\", \"one\", \"two\", \"two\"],\n                       C = [\"small\", \"large\", \"large\", \"small\",\n                       \"small\", \"large\", \"small\", \"small\",\n                       \"large\"],\n                       D = [1, 2, 2, 3, 3, 4, 5, 6, 7],\n                       E = [2, 4, 5, 5, 6, 6, 8, 9, 9])\n9×5 Dataset\n Row │ A         B         C         D         E        \n     │ identity  identity  identity  identity  identity\n     │ String?   String?   String?   Int64?    Int64?   \n─────┼──────────────────────────────────────────────────\n   1 │ foo       one       small            1         2\n   2 │ foo       one       large            2         4\n   3 │ foo       one       large            2         5\n   4 │ foo       two       small            3         5\n   5 │ foo       two       small            3         6\n   6 │ bar       one       large            4         6\n   7 │ bar       one       small            5         8\n   8 │ bar       two       small            6         9\n   9 │ bar       two       large            7         9\n\njulia> ; # This first example aggregates values by taking the sum.\njulia> _tmp = combine(groupby(ds, 1:3), 4=>IMD.sum);\n\njulia> transpose(gatherby(_tmp, 1:2, isgathered = true), :sum_D, id = :C, variable_name = nothing)\n4×4 Dataset\n Row │ A         B         large     small    \n     │ identity  identity  identity  identity\n     │ String?   String?   Int64?    Int64?   \n─────┼────────────────────────────────────────\n   1 │ bar       one              4         5\n   2 │ bar       two              7         6\n   3 │ foo       one              4         1\n   4 │ foo       two        missing         6\n\njulia> transpose(gatherby(_tmp, 1:2, isgathered = true), :sum_D, id = :C, variable_name = nothing, default = 0)\n4×4 Dataset\n Row │ A         B         large     small    \n     │ identity  identity  identity  identity\n     │ String?   String?   Int64?    Int64?   \n─────┼────────────────────────────────────────\n   1 │ bar       one              4         5\n   2 │ bar       two              7         6\n   3 │ foo       one              4         1\n   4 │ foo       two              0         6\n\njulia> ; # The next example aggregates by taking the mean across multiple columns. Here we don't need transposing\njulia> combine(groupby(ds, [:A, :C]), [:D, :E] => mean)\n4×4 Dataset\n Row │ A         C         mean_D    mean_E   \n     │ identity  identity  identity  identity\n     │ String?   String?   Float64?  Float64?\n─────┼────────────────────────────────────────\n   1 │ bar       large      5.5       7.5\n   2 │ bar       small      5.5       8.5\n   3 │ foo       large      2.0       4.5\n   4 │ foo       small      2.33333   4.33333\n\njulia> combine(groupby(ds, [:A, :C]), :D => mean, :E => [IMD.minimum, IMD.maximum, mean])\n4×6 Dataset\n Row │ A         C         mean_D    minimum_E  maximum_E  mean_E   \n     │ identity  identity  identity  identity   identity   identity\n     │ String?   String?   Float64?  Int64?     Int64?     Float64?\n─────┼──────────────────────────────────────────────────────────────\n   1 │ bar       large      5.5              6          9   7.5\n   2 │ bar       small      5.5              8          9   8.5\n   3 │ foo       large      2.0              4          5   4.5\n   4 │ foo       small      2.33333          2          6   4.33333","category":"page"},{"location":"man/missing/#How-InMemoryDatasets-treats-missing-values?","page":"Missing Values","title":"How InMemoryDatasets treats missing values?","text":"","category":"section"},{"location":"man/missing/#Comparing-data-sets","page":"Missing Values","title":"Comparing data sets","text":"","category":"section"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"== of two data sets or two DatasetColumns falls back to isequal.","category":"page"},{"location":"man/missing/#Every-column-supports-missing","page":"Missing Values","title":"Every column supports missing","text":"","category":"section"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"The Dataset() constructor automatically converts each column of a data set to allow ‍‍‍‍‍missing when constructs a data set. All algorithms in InMemoryDatasets are optimised to minimised the overhead of supporting missing type.","category":"page"},{"location":"man/missing/#Functions-which-skip-missing-values","page":"Missing Values","title":"Functions which skip missing values","text":"","category":"section"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"InMemoryDatasets has a set of functions which removes missing values. The following list summarises the details of how InMemoryDatasets removes/skips/ignores missing values (for the rest of this section INTEGERS refers to {U/Int8, U/Int16, U/Int32, U/Int64} and FLOATS refers to {Float16, Float32, Float64}):","category":"page"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"IMD.argmax : For INTEGERS, FLOATS, TimeType, and AbstractString skip missing values. When all values are missing, it returns missing.\nIMD.argmin : For INTEGERS, FLOATS, TimeType, and AbstractString skip missing values. When all values are missing, it returns missing.\nIMD.cummax : For INTEGERS, FLOATS, and TimeType ignore missing values, however, by passing missings = :skip it jumps over missing values. When all values are missing, it returns the input.\nIMD.cummax!: For INTEGERS, FLOATS, and TimeType ignore missing values, however, by passing missings = :skip it jumps over missing values. When all values are missing, it returns the input.\nIMD.cummin : For INTEGERS, FLOATS, and TimeType ignore missing values, however, by passing missings = :skip it jumps over missing values. When all values are missing, it returns the input.\nIMD.cummin!: For INTEGERS, FLOATS, and TimeType ignore missing values, however, by passing missings = :skip it jumps over missing values. When all values are missing, it returns the input.\nIMD.cumprod : For INTEGERS and FLOATS ignore missing values, however, by passing missings = :skip it jumps over missing values. When all values are missing, it returns the input.\nIMD.cumprod!: For INTEGERS and FLOATS ignore missing values, however, by passing missings = :skip it jumps over missing values. When all values are missing, it returns the input.\nIMD.cumsum : For INTEGERS and FLOATS ignore missing values, however, by passing missings = :skip it jumps over missing values. When all values are missing, it returns the input.\nIMD.cumsum! : For INTEGERS and FLOATS ignore missing values, however, by passing missings = :skip it jumps over missing values. When all values are missing, it returns the input.\nIMD.extrema : For INTEGERS, FLOATS, and TimeType skip missing values. When all values are missing, it returns (missing, missing).\nIMD.findmax : For INTEGERS, FLOATS, TimeType, and AbstractString skip missing values. When all values are missing, it returns (missing, missing).\nIMD.findmin : For INTEGERS, FLOATS, TimeType, and AbstractString skip missing values. When all values are missing, it returns (missing, missing).\nIMD.maximum : For INTEGERS, FLOATS, TimeType, and AbstractString skip missing values. When all values are missing, it returns missing.\nIMD.mean : For INTEGERS and FLOATS skip missing values. When all values are missing, it returns missing\nIMD.median : For INTEGERS and FLOATS skip missing values. When all values are missing, it returns missing\nIMD.median!  : For INTEGERS and FLOATS skip missing values. When all values are missing, it returns missing\nIMD.minimum : For INTEGERS, FLOATS, TimeType, and AbstractString skip missing values. When all values are missing, it returns missing.\nIMD.std : For INTEGERS and FLOATS skip missing values. When all values are missing, it returns missing\nIMD.sum : For INTEGERS and FLOATS skip missing values. When all values are missing, it returns missing\nIMD.var : For INTEGERS and FLOATS skip missing values. When all values are missing, it returns missing","category":"page"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"julia> x = [1,1,missing]\n3-element Vector{Union{Missing, Int64}}:\n 1\n 1\n  missing\n\njulia> IMD.sum(x)\n2\n\njulia> IMD.mean(x)\n1.0\n\njulia> IMD.maximum(x)\n1\n\njulia> IMD.minimum(x)\n1\n\njulia> IMD.findmax(x)\n(1, 1)\n\njulia> IMD.findmin(x)\n(1, 1)\n\njulia> IMD.cumsum(x)\n3-element Vector{Union{Missing, Int64}}:\n 1\n 2\n 2\n\njulia> IMD.cumsum(x, missings = :skip)\n3-element Vector{Union{Missing, Int64}}:\n 1\n 2\n  missing\n\njulia> IMD.cumprod(x, missings = :skip)\n3-element Vector{Union{Missing, Int64}}:\n 1\n 1\n  missing\n\njulia> IMD.median(x)\n1.0","category":"page"},{"location":"man/missing/#Some-remarks","page":"Missing Values","title":"Some remarks","text":"","category":"section"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"var and std will return missing when dof = true and an AbstractVector of length one is passed as their argument. This is different from the behaviour of these functions defined in the Statistics package.","category":"page"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"julia> IMD.var([1])\nmissing\n\njulia> IMD.std([1])\nmissing\n\njulia> Statistics.var([1])\nNaN\n\njulia> Statistics.std([1])\nNaN","category":"page"},{"location":"man/missing/#Multithreaded-functions","page":"Missing Values","title":"Multithreaded functions","text":"","category":"section"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"The IMD.sum, IMD.minimum, and IMD.maximum functions also support the threads keyword argument. When it is set to true, they exploit all cores for calculation.","category":"page"},{"location":"man/missing/#Other-functions","page":"Missing Values","title":"Other functions","text":"","category":"section"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"The following functions are also exported by InMemoryDatasets:","category":"page"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"bfill : backward filling\nbfill! : backward filling in-place\nffill : forward filling\nffill! : forward filling in-place\nlag : Create a lag-k of the provided vector\nlag! : Replace its input with a lag-k values\nlead : Create a lead-k of the provided vector\nlead! : Replace its input with a lead-k values\ntopk : Return top(bottom) k values of a vector. It ignores missing values, unless all values are missing which it returns [missing].\ntopkperm :  Return the indices of top(bottom) k values of a vector. It ignores missing values, unless all values are missing which it returns [missing].","category":"page"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"and the following functions are not exported but are available via dot notation:","category":"page"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"InMemoryDatasets.n or IMD.n : Return number of non-missing elements\nInMemoryDatasets.nmissing or IMD.nmissing : Return number of missing elements","category":"page"},{"location":"man/missing/","page":"Missing Values","title":"Missing Values","text":"julia> x = [13, 1, missing, 10]\n4-element Vector{Union{Missing, Int64}}:\n 13\n  1\n   missing\n 10\n\njulia> topk(x, 2)\n2-element Vector{Int64}:\n 13\n 10\n\njulia> topk(x, 2, rev = true)\n2-element Vector{Int64}:\n  1\n 10\njulia> IMD.n(x)\n3\n\njulia> IMD.nmissing(x)\n1","category":"page"},{"location":"man/modify/#Transforming-data-sets","page":"Transform columns","title":"Transforming data sets","text":"","category":"section"},{"location":"man/modify/#Introduction","page":"Transform columns","title":"Introduction","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"The modify! function can be used to transform and modify columns of a data set. Note that the function modifies the data set in-place and operates on actual values (rather than the formatted values). To modify a copy of data we should use the modify function. These two functions accept one column of data set and apply the provided functions on the fed column as a vector, this should be compared to map!/map functions which apply operations on individual observations.","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"Note that modify!/modify remove the format of columns as soon as their values are updated by a given transformation.","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"By default, these functions use multithreaded computation when a grouped data set is passed as their arguments, however, passing threads =  false changes this.","category":"page"},{"location":"man/modify/#Specifying-the-transformation","page":"Transform columns","title":"Specifying the transformation","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"The first argument of these two functions is the name of the data set which is going to be modified and the next arguments can be the transform specifications, i.e.","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"modify!(ds, args...) or modify(ds, args...)","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"The simplest form of args is col => fun which calls fun on col as a vector and replaces col with the output of the call. col can be a column index or a column name. Thus, to replace the value of a column which is called :x1 in a data set ds with their standardised values, we can use the following expression:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"modify!(ds, :x1 => stdze)","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"where :x1 is a column in ds, and stdze is a function which subtracts values by their mean and divide them by their standard deviation. If you don't want to replace the column, but instead you like to create a new column based on calling fun on col, the col => fun => :newname (here :newname is a name for the new column) form is handy. Thus, to standardised the values of a column, which is called :x1, and store them as a new column in the data set, you can use,","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"modify!(ds, :x1 => stdze => :x1_stdze)","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"To modify multiple columns of a data set with the same fun, we can use the cols => fun, where cols is a set of columns, this includes, a vector of columns indices, a vector of column names, a regular expression which selects some of the variables based on their names, or Between and Not types. When cols is referring to multiple columns, modify! automatically expands cols => fun to col1 => fun, col2 => fun, ..., where col1 is the first column in the selected columns, col2 is the second one, and so on. Thus to standardised all columns which starts with x in a data set, we can use the following expression:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"modify!(ds, r\"^x\" => stdze)","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"Note that the Julia broadcasting can be also used for specifying args..., e.g. something like:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"[1, 2, 3] .=> [stdze, x -> x .- mean(x), x -> x ./ sum(x)] .=> [:stdze_1, :m_2, :m_3]","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"will be translated as:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"1 => stdze => :stdze_1, 2 => (x -> x .- mean(x)) => :m_2, 3 => (x -> x ./ sum(x)) => :m_3,","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"and something like:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":":x1 .=> [sum, sort] .=> [:x1_sum, :x1_sort]","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"will be translated as:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":":x1 => sum => :x1_sum, :x1 => sort => :x1_sort.","category":"page"},{"location":"man/modify/#Examples","page":"Transform columns","title":"Examples","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"julia> ds = Dataset(x1 = 1:5, x2 = [-2, -1, missing, 1, 2],\n                    x3 = [0.0, 0.1, 0.2, missing, 0.4])\n5×3 Dataset\n Row │ x1        x2        x3\n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1        -2       0.0\n   2 │        2        -1       0.1\n   3 │        3   missing       0.2\n   4 │        4         1   missing\n   5 │        5         2       0.4\n\njulia> modify!(ds, 2:3 => IMD.sum)\n5×3 Dataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity\n     │ Int64?    Int64?    Float64?\n─────┼──────────────────────────────\n   1 │        1         0       0.7\n   2 │        2         0       0.7\n   3 │        3         0       0.7\n   4 │        4         0       0.7\n   5 │        5         0       0.7\n\njulia> modify!(ds, :x1 => x -> x .- IMD.mean(x))\n5×3 Dataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity\n     │ Float64?  Int64?    Float64?\n─────┼──────────────────────────────\n   1 │     -2.0         0       0.7\n   2 │     -1.0         0       0.7\n   3 │      0.0         0       0.7\n   4 │      1.0         0       0.7\n   5 │      2.0         0       0.7","category":"page"},{"location":"man/modify/#Accessing-to-modified-columns","page":"Transform columns","title":"Accessing to modified columns","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"One of the key features of modify!/modify is that these functions have access to all modified/created variable in a single run of the function. It means, every transformation can be done on all columns that have been or updated by args arguments or any column which is created by col => fun => :newname syntax. In other words, for args... from left to right whenever a column is updated or created, the next operation has access to its value (either new or updated values). This will be particularly useful in conjunction with byrow which performs row-wise operations.","category":"page"},{"location":"man/modify/#Specialised-functions","page":"Transform columns","title":"Specialised functions","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"There are two functions in Datasets which are very handy to modify a data set: byrow, and splitter.","category":"page"},{"location":"man/modify/#byrow","page":"Transform columns","title":"byrow","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"The byrow function is discussed in length in another section as a stand-alone function, however, it can also be used as the fun when we want to specify the transformation in modify!/modify. The syntax of byrow is different from its stand-alone usage in the way that when byrow is the fun part of args in the syntax of modify!/modify functions, we don't need to specify ds and cols, however, every other arguments are the same as the stand-alone usage.","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"The main feature of byrow inside modify!/modify  is that it can accept multiple columns as the input argument, opposed to the other functions inside modify!/modify which only accept single column. This and the fact that every transformation inside modify!/modify has access to modified columns, help to provide complex transformations in a single run of modify!/modify.","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"The form of args when byrow is the function is similar to other functions with the following exceptions:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"When cols refers to multiple columns in cols => byrow(...), modify!/modify will create a new column with a names based on the arguments passed to it. The user can provide a custom name by using the cols => byrow(...) => :newname syntax.\nWhen col refers to a single column in col => byrow(...), modify!/modify will apply operation on single values of the column and replace the column with the new values, i.e. it doesn't create a new column.\nTo use broadcasting with byrow, i.e. applying the same row-wise operation on multiple columns, the form must be cols .=> byrow where cols is a vector of column names or column indices (regular expression cannot be used for this purpose).","category":"page"},{"location":"man/modify/#splitter","page":"Transform columns","title":"splitter","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"splitter is also a specialised function which has a single job: splitting a single column which is a Tuple of values into multiple columns. It only operates on a single columns and the values inside the column which needs to be split must be in the form of Tuples. The form of args for splitter must be similar to:","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"modify!(ds, col => splitter => [:new_col_1, :new_col_2])","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"which means we like to split col into two new columns; :new_col_1 and :new_col_2. Here col can be a column index or a column name.","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"Note, splitter produces as many columns as the length of the given new names, i.e. if the user provides fewer names than needed, the output columns will only contain partial components of the input Tuple.","category":"page"},{"location":"man/modify/#Examples-2","page":"Transform columns","title":"Examples","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"julia> body = Dataset(weight = [78.5, 59, 80], height = [160, 171, 183])\n3×2 Dataset\n Row │ weight    height   \n     │ identity  identity\n     │ Float64?  Int64?   \n─────┼────────────────────\n   1 │     78.5       160\n   2 │     59.0       171\n   3 │     80.0       183\n\njulia> modify!(body, :height => byrow(x -> (x/100)^2) => :BMI, [1, 3] => byrow(/) => :BMI)\n3×3 Dataset\n Row │ weight    height    BMI      \n     │ identity  identity  identity\n     │ Float64?  Int64?    Float64?\n─────┼──────────────────────────────\n   1 │     78.5       160   30.6641\n   2 │     59.0       171   20.1771\n   3 │     80.0       183   23.8884\n\njulia> sale = Dataset(customer = [\"Bob Smith\", \"John Max\", \"Froon Moore\"],\n       item1_q1 = [23, 43, 50], item2_q1 = [44, 32, 55],\n       item3_q1 = [45, 45, 54])\n3×4 Dataset\n Row │ customer     item1_q1  item2_q1  item3_q1\n     │ identity     identity  identity  identity\n     │ String?      Int64?    Int64?    Int64?   \n─────┼───────────────────────────────────────────\n   1 │ Bob Smith          23        44        45\n   2 │ John Max           43        32        45\n   3 │ Froon Moore        50        55        54\n\njulia> modify!(sale, 2:4 => byrow(sum) => :total)\n3×5 Dataset\n Row │ customer     item1_q1  item2_q1  item3_q1  total    \n     │ identity     identity  identity  identity  identity\n     │ String?      Int64?    Int64?    Int64?    Int64?   \n─────┼─────────────────────────────────────────────────────\n   1 │ Bob Smith          23        44        45       112\n   2 │ John Max           43        32        45       120\n   3 │ Froon Moore        50        55        54       159\n\njulia> function name_split(x)\n           spl = split(x, \" \")\n           (string(spl[1]), string(spl[2]))\n       end\nname_split (generic function with 1 method)\n\njulia> modify!(sale, :customer => byrow(name_split),\n                     :customer => splitter => [:first_name, :last_name])\n3×7 Dataset\n Row │ customer            item1_q1  item2_q1  item3_q1  total     first_name  last_name\n     │ identity            identity  identity  identity  identity  identity    identity  \n     │ Tuple…?             Int64?    Int64?    Int64?    Int64?    String?     String?   \n─────┼───────────────────────────────────────────────────────────────────────────────────\n   1 │ (\"Bob\", \"Smith\")          23        44        45       112  Bob         Smith\n   2 │ (\"John\", \"Max\")           43        32        45       120  John        Max\n   3 │ (\"Froon\", \"Moore\")        50        55        54       159  Froon       Moore\n","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"In the last example, we use byrow to apply name_split on each row of :customer, and since there is only one column as the input of byrow, modify! replaces the column with the new values. Also, note that the modify! function has access to these new values and we can use splitter to split the column into two new columns.","category":"page"},{"location":"man/modify/#Using-Tuple-of-column-names","page":"Transform columns","title":"Using Tuple of column names","text":"","category":"section"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"When the form of the transform specifications is as NTuple{col} => fun, modify! and modify assumes that the fun function accepts multiple arguments (multiple columns).","category":"page"},{"location":"man/modify/","page":"Transform columns","title":"Transform columns","text":"julia> body = Dataset(weight = [78.5, 59, 80], height = [160, 171, 183])\n3×2 Dataset\n Row │ weight    height   \n     │ identity  identity\n     │ Float64?  Int64?   \n─────┼────────────────────\n   1 │     78.5       160\n   2 │     59.0       171\n   3 │     80.0       183\n\njulia> modify(body, (:weight, :height)=> cor)\n3×3 Dataset\n Row │ weight    height    cor_weight_height\n     │ identity  identity  identity          \n     │ Float64?  Int64?    Float64?          \n─────┼───────────────────────────────────────\n   1 │     78.5       160          0.0890411\n   2 │     59.0       171          0.0890411\n   3 │     80.0       183          0.0890411","category":"page"},{"location":"#InMemoryDatasets.jl","page":"Introduction","title":"InMemoryDatasets.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the InMemoryDatasets.jl documentation!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This resource aims to teach you everything you need to know to get up and running with the InMemoryDatasets.jl package.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"InMemoryDatasets is a collection of tools for working (manipulating, wrangling, cleaning, summarising,...) with tabular data in Julia.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you are new to InMemoryDatasets.jl, probably First steps with Datasets or Tutorial in manual should be good starting points.","category":"page"},{"location":"#Package-manual","page":"Introduction","title":"Package manual","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"man/basics.md\",\n         \"man/tutorial.md\",\n         \"man/missing.md\",\n         \"man/formats.md\",\n         \"man/map.md\",\n         \"man/byrow.md\",\n         \"man/modify.md\",\n         \"man/filter.md\",\n         \"man/sorting.md\",\n         \"man/grouping.md\",\n         \"man/aggregation.md\",\n         \"man/transpose.md\",\n         \"man/joins.md\",\n         \"man/gallery.md\",\n         \"man/performance.md\"]\nDepth = 2","category":"page"},{"location":"#API","page":"Introduction","title":"API","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Only exported (i.e. available for use without InMemoryDatasets. qualifier after loading the InMemoryDatasets.jl package with using InMemoryDatasets) types and functions are considered a part of the public API of the InMemoryDatasets.jl package. In general all such objects are documented in this manual (in case some documentation is missing please kindly report an issue here).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Please be warned that while Julia allows you to access internal functions or types of InMemoryDatasets.jl these can change without warning between versions of InMemoryDatasets.jl. In particular it is not safe to directly access fields of types that are a part of public API of the InMemoryDatasets.jl package using e.g. the getfield function. Whenever some operation on fields of defined types is considered allowed an appropriate exported function should be used instead.","category":"page"},{"location":"man/byrow/#Function-byrow","page":"Row-wise operations","title":"Function byrow","text":"","category":"section"},{"location":"man/byrow/#Introduction","page":"Row-wise operations","title":"Introduction","text":"","category":"section"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The byrow function is a high performance (multi-threaded) function for row-wise operations. It is designed to make tasks like summing up each row simple, efficient, and lightening fast. The function can be used as a stand-alone function or inside modify/modify! or combine functions. The stand-alone syntax of the function is byrow(ds, fun, cols, ...), where ds is a data set, fun is a function, and cols  is the list of columns which row-wise operation is going to be applied on their values in each row, e.g. the following code creates a data set with 100,000 rows and 100 columns, and adds the values in each row,","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> ds = Dataset(rand(10^5, 100), :auto);\njulia> byrow(ds, sum, 1:100)\n100000-element Vector{Union{Missing, Float64}}:\n 50.655934293702366\n 51.481108371018266\n 51.27498152964299\n 54.097941432844536\n 52.28727157779627\n 56.215091415376975\n 53.940023864095856\n 47.65424080373157\n  ⋮\n 46.360565247921\n 45.91721147194705\n 52.047072415296824\n 48.71125460530455\n 50.82102574082131\n 49.90462723123929\n 46.594683329278816\n 50.47529543725829","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"As it can be observed the function syntax is very straightforward, and to examine the efficiency of it, we use the @btime macro from the BenchmarkTools package,","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> using BenchmarkTools\njulia> @btime byrow(ds, sum, 1:100);\n  4.528 ms (1587 allocations: 919.97 KiB)\njulia> m = Matrix(ds)\njulia> @btime sum(m, dims = 2)\n  14.867 ms (7 allocations: 879.11 KiB)","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"In the above benchmark, byrow should be even more performant when the data set has a group of heterogeneous columns.","category":"page"},{"location":"man/byrow/#Optimised-operations","page":"Row-wise operations","title":"Optimised operations","text":"","category":"section"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Generally, byrow is efficient for any fun which returns a single value for each row, however, it is fine tuned for the following functions: (for details of each of the following function refer to its docstring by typing ?byrow(fun) in a Julia session, e.g. ?byrow(sum))","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"all : Test whether all elements of a boolean collection are true\nany : Test whether any elements of a boolean collection are true\nargmax : Return the column name of the maximum element\nargmin : Return the column name of the minimum element\ncoalesce : Return the first value which is not equal to missing\ncount : Count the number of trues\nfindfirst : Return the column name of the first true value. Alternatively, user can pass a vector of values to item to search for the first column with the same value.\nfindlast : Return the column name of the last true value. Alternatively, user can pass a vector of values to item to search for the first column with the same value.\nhash : Compute an integer hash code\nin : Determine whether values passed via the item keyword argument are in the given collection of columns.\nisequal : Return true when all values are equal. Optionally, a vector of values can be passed via the with keyword to compare equality with it.\nisless : Return true when all values are less than passed vector(or column specified by its name) as with. Passing rev = true change less to greater.\nissorted : Check if the values are sorted\njoin: Convert values in each row to string and join them into a single string, inserting the given delimiter (if any) between adjacent values. If last is given, it will be used instead of delim between the last two strings.\nmaximum : Return the maximum value\nmean : Compute the mean value\nminimum : Return the minimum value\nnunique : Return the number of unique values\nprod : Return the product of values\nselect : Select values of specific columns in each row. The specific columns can be passed using with = scols, where scols can be a vector of columns names or a column name of the passed data set.\nstd : Compute the standard deviation of values\nsum : Return the sum of values\nvar : Compute the variance of values","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The common syntax of byrow for most of these functions is:","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"byrow(ds, fun, cols; [by , threads = true])","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The by keyword argument is for specifying a function to call on each value before calling fun to aggregate the result, and threads = true causes byrow to exploit all cores available to Julia for performing the computations.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The nunique function doesn't accept threads argument, however, it has an extra keyword argument count_missing. nunique counts the number of unique values of each row, and count_missing = true counts missings as a unique value.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The coalesce and issorted functions don't accept by argument, however, issorted and isless accept extra keyword argument rev which is set to false by default, and isequal, select, and isless accept extra keyword argument with for passing a vector of values or a column name.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"By default, issorted and isless use the isless function for comparing values, however, user can pass any other function via the lt keyword argument.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"A column name or a vector of values must be passed via item if in operation is used in byrow. By default, in operation uses isequal(item, collection) for determining whether an item is in the given collection, however, any user defined function passed via the eq keyword argument can replace it. Both findfirst and findlast support the eq keyword argument.","category":"page"},{"location":"man/byrow/#Examples","page":"Row-wise operations","title":"Examples","text":"","category":"section"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Let's first create an example data set which we will use for the rest of this section:","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> ds = Dataset(g = [1, 1, 1, 2, 2],\n                    x1_int = [0, 0, 1, missing, 2],\n                    x2_int = [3, 2, 1, 3, -2],\n                    x1_float = [1.2, missing, -1.0, 2.3, 10],\n                    x2_float = [missing, missing, 3.0, missing, missing],\n                    x3_float = [missing, missing, -1.4, 3.0, -100.0])\n5×6 Dataset\n Row │ g         x1_int    x2_int    x1_float   x2_float   x3_float\n     │ identity  identity  identity  identity   identity   identity\n     │ Int64?    Int64?    Int64?    Float64?   Float64?   Float64?\n─────┼───────────────────────────────────────────────────────────────\n   1 │        1         0         3        1.2  missing    missing\n   2 │        1         0         2  missing    missing    missing\n   3 │        1         1         1       -1.0        3.0       -1.4\n   4 │        2   missing         3        2.3  missing          3.0\n   5 │        2         2        -2       10.0  missing       -100.0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"To compute the mean of each row for the float columns, we simply call,","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, mean, r\"_float\")\n5-element Vector{Union{Missing, Float64}}:\n   1.2\n    missing\n   0.20000000000000004\n   2.65\n -45.0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Note that, since for the second row all values are missing, the result of mean is also missing.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"To calculate the mean of the absolute value of each row for the float columns we use the same code and pass by = abs as the keyword argument,","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, mean, r\"_float\", by = abs)\n5-element Vector{Union{Missing, Float64}}:\n  1.2\n   missing\n  1.8\n  2.65\n 55.0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"To find rows which all their values are greater than 0 in the first three columns we can use the following code,","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, all, 1:3, by = x -> isless(0, x))\n5-element Vector{Bool}:\n 0\n 0\n 1\n 1\n 0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Note that in Julia isless(0, missing) is true.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"To find rows which contain at least one missing value in any of the columns we can use the following code,","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, any, :, by = ismissing)\n5-element Vector{Bool}:\n 1\n 1\n 0\n 1\n 1","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"It means that except the third row, all other rows contain missing values. Using byrow with count function, we can count the number of non-missing values in each row,","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, count, :, by = !ismissing)\n5-element Vector{Int32}:\n 4\n 3\n 6\n 4\n 5","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"To check if in each row all integer columns are less(greater) than x1_float we should use the following code:","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, isless, r\"int\", with = :x1_float)\n5-element Vector{Bool}:\n 0\n 1\n 0\n 0\n 1\n\njulia> byrow(ds, isless, r\"int\", with = :x1_float, rev = true) # greater\n5-element Vector{Bool}:\n 0\n 0\n 1\n 1\n 0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"In the following example, in each row we pick the values of selected columns passed by the with keyword argument.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> ds2 = Dataset(x1 = 1:4, x2 = [1,2,1,2], NAMES = [:x1, :x2, :x1, :x1])\n4×3 Dataset\n Row │ x1        x2        NAMES    \n     │ identity  identity  identity\n     │ Int64?    Int64?    Symbol?  \n─────┼──────────────────────────────\n   1 │        1         1  x1\n   2 │        2         2  x2\n   3 │        3         1  x1\n   4 │        4         2  x1\n\njulia> byrow(ds2, select, r\"x\", with = :NAMES)\n4-element Vector{Union{Missing, Int64}}:\n 1\n 2\n 3\n 4\n\njulia> byrow(ds2, select, r\"x\", with = [\"x1\", \"x2\", \"x2\", \"x2\"])\n4-element Vector{Union{Missing, Int64}}:\n 1\n 2\n 1\n 2\n\njulia> byrow(ds2, select, [:x2, :x1], with = [1,2,2,1])\n4-element Vector{Union{Missing, Int64}}:\n 1\n 2\n 3\n 2","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"In the last example, note that the integers in with are mapped to the corresponding columns passed to the function, i.e. 1 is referring to :x2 (it is the first column passed to the function as the column selector) and 2 is referring to :x1.","category":"page"},{"location":"man/byrow/#mapreduce","page":"Row-wise operations","title":"mapreduce","text":"","category":"section"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"One special function that can be used as fun in the byrow function is mapreduce. This can be used to implement a customised reduction as row operation. When mapreduce is used in byrow, two keyword arguments must be passed, op and init. For example in the following code we use mapreduce to sum all values in each row: (note that unlike byrow(ds, sum, :) the following function will return missing for a row if any of the value in that row is missing)","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"byrow(ds, mapreduce, :, op = .+, init = zeros(nrow(ds)))","category":"page"},{"location":"man/byrow/#User-defined-operations","page":"Row-wise operations","title":"User defined operations","text":"","category":"section"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"For user defined functions which return a single value, byrow treats each row as a vector of values, thus the user defined function must accept a vector and returns a single value. However, when user defines a multivariate function and pass a Tuple of column indices as the cols argument of byrow, the byrow function simply calls fun.(ds[:, cols[1]], ds[:, cols2], ...). Currently, the threads keyword argument is not available for this case.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"For instance to calculate 1 * col1 + 2 * col2 + 3 * col3 for each row in ds we can define the following function:","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> avg(x) = 1 * x[1] + 2 * x[2] + 3 * x[3]\navg (generic function with 1 method)","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"and directly use it in byrow,","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> byrow(ds, avg, 1:3)\n5-element Vector{Union{Missing, Int64}}:\n 10\n  7\n  6\n   missing\n  0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Note that avg is missing if any of the values in x is missing.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Below is an example of using byrow with a user defined multivariate function","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> ds = Dataset(x1 = [1,2,1,2], x2 = [1,-2,-3,10], x3 = 1:4)\n4×3 Dataset\n Row │ x1        x2        x3       \n     │ identity  identity  identity \n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        1         1         1\n   2 │        2        -2         2\n   3 │        1        -3         3\n   4 │        2        10         4\n\njulia> fun(x,y,z)::Float64 = x == 1 ? y*z : y/z\nfun (generic function with 1 method)\n\njulia> byrow(ds, fun, (:x1, :x2, :x3))\n4-element Vector{Real}:\n  1.0\n -1.0\n -9.0\n  2.5","category":"page"},{"location":"man/byrow/#Special-operations","page":"Row-wise operations","title":"Special operations","text":"","category":"section"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"byrow also supports a few optimised operations which return a vector of values for each row. The fun argument for these operations is one of the followings:","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"cummax\ncummax!\ncummin\ncummin!\ncumprod\ncumprod!\ncumsum\ncumsum!\nfill\nfill!\nsort\nsort!\nstdze\nstdze!","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The main difference between these operations and the previous operations is that these operations return a data set with the corresponding row has been updated with the operation. For the operations with ! the updated version of the original data set is returned and for the operations without ! a modified copy of the original data set is returned.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The fill and fill! functions fill values which calling the function passed as by on them returns true with values passed to the with keyword argument. The function passed to the by keyword argument must return true or false and by default it is set to by = ismissing.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Note that for the fill and fill! functions the filling happens in-place, thus, if this is not possible Julia will throw errors.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> ds = Dataset(x1 = [missing, 2, 1], x2 = [1, missing, missing], y = [4,5,3])\n3×3 Dataset\n Row │ x1        x2        y        \n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │  missing         1         4\n   2 │        2   missing         5\n   3 │        1   missing         3\n\njulia> byrow(ds, fill, 1:2, with = :y)\n3×3 Dataset\n Row │ x1        x2        y        \n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        4         1         4\n   2 │        2         5         5\n   3 │        1         3         3\n\njulia> byrow(ds, fill, 1:2, with = [0,2,1])\n3×3 Dataset\n Row │ x1        x2        y        \n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        0         1         4\n   2 │        2         2         5\n   3 │        1         1         3\n\njulia> byrow(ds, fill, 1:2, with = [0,2,1], by = x->ismissing(x) || isequal(x, 1))\n3×3 Dataset\n Row │ x1        x2        y        \n     │ identity  identity  identity\n     │ Int64?    Int64?    Int64?   \n─────┼──────────────────────────────\n   1 │        0         0         4\n   2 │        2         2         5\n   3 │        1         1         3","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"the cumulative functions calculate the cumulative min, max, sum, and product, sort sorts the values in each row, and stdze standardises the values in each row. The sort operation accepts all keyword arguments that the function sort in Julia Base accept.","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"julia> ds = Dataset(g = [1, 1, 1, 2, 2],\n                    x1_int = [0, 0, 1, missing, 2],\n                    x2_int = [3, 2, 1, 3, -2],\n                    x1_float = [1.2, missing, -1.0, 2.3, 10],\n                    x2_float = [missing, missing, 3.0, missing, missing],\n                    x3_float = [missing, missing, -1.4, 3.0, -100.0]);\njulia> byrow(ds, cumsum, 1:3)\n5×6 Dataset\n Row │ g         x1_int    x2_int    x1_float   x2_float   x3_float\n     │ identity  identity  identity  identity   identity   identity\n     │ Int64?    Int64?    Int64?    Float64?   Float64?   Float64?\n─────┼───────────────────────────────────────────────────────────────\n   1 │        1         1         4        1.2  missing    missing\n   2 │        1         1         3  missing    missing    missing\n   3 │        1         2         3       -1.0        3.0       -1.4\n   4 │        2         2         5        2.3  missing          3.0\n   5 │        2         4         2       10.0  missing       -100.0","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"Note that for these operations, by default, cumsum/!, cumprod/!, cumax/!, and cummin/! ignore missing values, however, passing missings = :skip causes these functions to skip the missing values (leave them as missing).","category":"page"},{"location":"man/byrow/","page":"Row-wise operations","title":"Row-wise operations","text":"The special operations don't change the columns names or their orders.","category":"page"},{"location":"assets/README/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"In this folder we store the following data sets:","category":"page"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"german_credit.csv\niris.csv","category":"page"},{"location":"assets/README/#German-Credit-data-set","page":"Introduction","title":"German Credit data set","text":"","category":"section"},{"location":"assets/README/#License:","page":"Introduction","title":"License:","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://opendatacommons.org/licenses/dbcl/1-0/","category":"page"},{"location":"assets/README/#Source:","page":"Introduction","title":"Source:","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://archive.ics.uci.edu/ml/datasets/statlog+(german+credit+data) Professor Dr. Hans Hofmann Institut für Statistik und Ökonometrie Universität Hamburg FB Wirtschaftswissenschaften Von-Melle-Park 5 2000 Hamburg 13","category":"page"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"The original data is from UCI, and the file stored here is from Kaggle","category":"page"},{"location":"assets/README/#Iris-data-set","page":"Introduction","title":"Iris data set","text":"","category":"section"},{"location":"assets/README/#License","page":"Introduction","title":"License","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://creativecommons.org/publicdomain/zero/1.0/","category":"page"},{"location":"assets/README/#Source:-2","page":"Introduction","title":"Source:","text":"","category":"section"},{"location":"assets/README/","page":"Introduction","title":"Introduction","text":"https://archive.ics.uci.edu/ml/datasets/Iris Creator: R.A. Fisher","category":"page"}]
}
